<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chirp SonicLib: soniclib.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" async src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Chirp SonicLib
   &#160;<span id="projectnumber">2.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">soniclib.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Chirp SonicLib public API and support functions for Chirp ultrasonic sensors.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ch101__gpr__open_8h_source.html">ch101_gpr_open.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ch101__gpr__sr__open_8h_source.html">ch101_gpr_sr_open.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ch101__gppc_8h_source.html">ch101_gppc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ch101__sonicsync_8h_source.html">ch101_sonicsync.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ch201__gprmt_8h_source.html">ch201_gprmt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ch201__gpr__str_8h_source.html">ch201_gpr_str.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ch101__floor_8h_source.html">ch101_floor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ch201__presence_8h_source.html">ch201_presence.h</a>&quot;</code><br />
<code>#include &quot;chirp_board_config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="ch__driver_8h_source.html">ch_driver.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ch__math__utils_8h_source.html">ch_math_utils.h</a>&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div>
<p><a href="soniclib_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structch__i2c__info__t.html">ch_i2c_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C info structure.  <a href="structch__i2c__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor I/Q data value.  <a href="structch__iq__sample__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structch__thresh__t.html">ch_thresh_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detection threshold value (CH201 only).  <a href="structch__thresh__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structch__thresholds__t.html">ch_thresholds_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiple detection threshold structure (CH201 only).  <a href="structch__thresholds__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structch__config__t.html">ch_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combined configuration structure.  <a href="structch__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structch__api__funcs__t.html">ch_api_funcs_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">API function pointer structure (internal use).  <a href="structch__api__funcs__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structch__group__t.html">ch_group_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chirp sensor group configuration structure.  <a href="structch__group__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structch__dev__t.html">ch_dev_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chirp sensor device structure.  <a href="structch__dev__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3407caaf3d2f8bb12e8c26bccbe3ae40"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a3407caaf3d2f8bb12e8c26bccbe3ae40">SONICLIB_VER_MAJOR</a>&#160;&#160;&#160;(2)</td></tr>
<tr class="separator:a3407caaf3d2f8bb12e8c26bccbe3ae40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3114f821e7b6c5971ddf1c363597b761"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a3114f821e7b6c5971ddf1c363597b761">SONICLIB_VER_MINOR</a>&#160;&#160;&#160;(1)</td></tr>
<tr class="separator:a3114f821e7b6c5971ddf1c363597b761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602271af8c1cf2ba218e68b49e5d465f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a602271af8c1cf2ba218e68b49e5d465f">SONICLIB_VER_REV</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:a602271af8c1cf2ba218e68b49e5d465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c47c2e19dd9fc3d57c60dac7961f89"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a93c47c2e19dd9fc3d57c60dac7961f89">CH101_PART_NUMBER</a>&#160;&#160;&#160;(101)</td></tr>
<tr class="separator:a93c47c2e19dd9fc3d57c60dac7961f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d3738677a6b10d44580771ed7b8481"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a56d3738677a6b10d44580771ed7b8481">CH201_PART_NUMBER</a>&#160;&#160;&#160;(201)</td></tr>
<tr class="separator:a56d3738677a6b10d44580771ed7b8481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a351939686e7af66da8f2b70a9b709"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a28a351939686e7af66da8f2b70a9b709">CH101_MAX_NUM_SAMPLES</a>&#160;&#160;&#160;(150)</td></tr>
<tr class="separator:a28a351939686e7af66da8f2b70a9b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ab2faf29aed6b745da4ef07ca0f832"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a26ab2faf29aed6b745da4ef07ca0f832">CH201_MAX_NUM_SAMPLES</a>&#160;&#160;&#160;(450)</td></tr>
<tr class="separator:a26ab2faf29aed6b745da4ef07ca0f832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb22435c0d7a9acf8898eefbaeb82791"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#acb22435c0d7a9acf8898eefbaeb82791">CH_NO_TARGET</a>&#160;&#160;&#160;(0xFFFFFFFF)</td></tr>
<tr class="separator:acb22435c0d7a9acf8898eefbaeb82791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9925720bfd6eb5d7a25cd04f6ef512"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a4f9925720bfd6eb5d7a25cd04f6ef512">CH_MIN_RANGE_VAL</a>&#160;&#160;&#160;(0x0001)</td></tr>
<tr class="separator:a4f9925720bfd6eb5d7a25cd04f6ef512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572265a83ea20b996e2b258388e36af2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a572265a83ea20b996e2b258388e36af2">CH_I2C_ADDR_PROG</a>&#160;&#160;&#160;(0x45)</td></tr>
<tr class="separator:a572265a83ea20b996e2b258388e36af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7cfa228dcd15d047c080e173593211"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a4f7cfa228dcd15d047c080e173593211">CH_SIG_BYTE_0</a>&#160;&#160;&#160;(0x0a)</td></tr>
<tr class="separator:a4f7cfa228dcd15d047c080e173593211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4290230eebe5289b9f009a7a2963cb6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ac4290230eebe5289b9f009a7a2963cb6">CH_SIG_BYTE_1</a>&#160;&#160;&#160;(0x02)</td></tr>
<tr class="separator:ac4290230eebe5289b9f009a7a2963cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564329279fbaa1d5d99bc15f30f229fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a564329279fbaa1d5d99bc15f30f229fe">CH_NUM_THRESHOLDS</a>&#160;&#160;&#160;(6)</td></tr>
<tr class="separator:a564329279fbaa1d5d99bc15f30f229fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be1394366f99b9be3c1602bc0425b67"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a9be1394366f99b9be3c1602bc0425b67">CH_SPEEDOFSOUND_MPS</a>&#160;&#160;&#160;(343)</td></tr>
<tr class="separator:a9be1394366f99b9be3c1602bc0425b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f072e4035752984408e51ca5118ed31"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a4f072e4035752984408e51ca5118ed31">I2C_DRV_FLAG_RESET_AFTER_NB</a>&#160;&#160;&#160;(0x00000001)</td></tr>
<tr class="separator:a4f072e4035752984408e51ca5118ed31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8793cb8505c41937c8efa88d16696b37"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a8793cb8505c41937c8efa88d16696b37">I2C_DRV_FLAG_USE_PROG_NB</a>&#160;&#160;&#160;(0x00000002)</td></tr>
<tr class="separator:a8793cb8505c41937c8efa88d16696b37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a264d79634c78878baa6f9ec9cd83c71f"><td class="memItemLeft" align="right" valign="top"><a id="a264d79634c78878baa6f9ec9cd83c71f"></a>
typedef struct <a class="el" href="structch__dev__t.html">ch_dev_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ch_dev_t</b></td></tr>
<tr class="separator:a264d79634c78878baa6f9ec9cd83c71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7fa7b1b94b0e0fb63518d23f155ec5"><td class="memItemLeft" align="right" valign="top"><a id="a3c7fa7b1b94b0e0fb63518d23f155ec5"></a>
typedef struct <a class="el" href="structch__group__t.html">ch_group_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ch_group_t</b></td></tr>
<tr class="separator:a3c7fa7b1b94b0e0fb63518d23f155ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9d2049253328d1a1c57458a70d29e9"><td class="memItemLeft" align="right" valign="top"><a id="a4e9d2049253328d1a1c57458a70d29e9"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a4e9d2049253328d1a1c57458a70d29e9">ch_fw_init_func_t</a>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t i2c_addr, uint8_t dev_num, uint8_t i2c_bus_index)</td></tr>
<tr class="memdesc:a4e9d2049253328d1a1c57458a70d29e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ASIC firmware init function pointer typedef. <br /></td></tr>
<tr class="separator:a4e9d2049253328d1a1c57458a70d29e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65288f02a091f49bd3f24eeffdff0c9"><td class="memItemLeft" align="right" valign="top"><a id="ac65288f02a091f49bd3f24eeffdff0c9"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ac65288f02a091f49bd3f24eeffdff0c9">ch_fw_load_func_t</a>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ac65288f02a091f49bd3f24eeffdff0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">API function pointer typedefs. <br /></td></tr>
<tr class="separator:ac65288f02a091f49bd3f24eeffdff0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf56bd1399ab66e3c363a3d8c68c1d21"><td class="memItemLeft" align="right" valign="top"><a id="aaf56bd1399ab66e3c363a3d8c68c1d21"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_config_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__config__t.html">ch_config_t</a> *config_ptr)</td></tr>
<tr class="separator:aaf56bd1399ab66e3c363a3d8c68c1d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d19cf4b2a948db25174f66dae10e6b"><td class="memItemLeft" align="right" valign="top"><a id="ab9d19cf4b2a948db25174f66dae10e6b"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_config_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__config__t.html">ch_config_t</a> *config_ptr)</td></tr>
<tr class="separator:ab9d19cf4b2a948db25174f66dae10e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2b171c4e0481f4eb9d1007e6726930"><td class="memItemLeft" align="right" valign="top"><a id="ada2b171c4e0481f4eb9d1007e6726930"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_mode_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a> mode)</td></tr>
<tr class="separator:ada2b171c4e0481f4eb9d1007e6726930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b39d08484eff318f00fb254c26f6a0"><td class="memItemLeft" align="right" valign="top"><a id="ac4b39d08484eff318f00fb254c26f6a0"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_sample_interval_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t sample_interval)</td></tr>
<tr class="separator:ac4b39d08484eff318f00fb254c26f6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76027f478783562d1e8a7dd7e11fbb07"><td class="memItemLeft" align="right" valign="top"><a id="a76027f478783562d1e8a7dd7e11fbb07"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_num_samples_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="separator:a76027f478783562d1e8a7dd7e11fbb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb7b3644cfeb3b3fa84cdfd45c7bffa2"><td class="memItemLeft" align="right" valign="top"><a id="acb7b3644cfeb3b3fa84cdfd45c7bffa2"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_max_range_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t max_range)</td></tr>
<tr class="separator:acb7b3644cfeb3b3fa84cdfd45c7bffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93afce5d9d43dc63cb2eed0e46afb232"><td class="memItemLeft" align="right" valign="top"><a id="a93afce5d9d43dc63cb2eed0e46afb232"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_sample_window_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t start_sample, uint16_t end_sample)</td></tr>
<tr class="separator:a93afce5d9d43dc63cb2eed0e46afb232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316798721ad4e2644fdbd2c07eab9299"><td class="memItemLeft" align="right" valign="top"><a id="a316798721ad4e2644fdbd2c07eab9299"></a>
typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_range_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0c">ch_range_t</a> range_type)</td></tr>
<tr class="separator:a316798721ad4e2644fdbd2c07eab9299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af7b9843d4d21b5ba6e0b0ffdf590ea"><td class="memItemLeft" align="right" valign="top"><a id="a2af7b9843d4d21b5ba6e0b0ffdf590ea"></a>
typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_tof_tick_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t timer_freq)</td></tr>
<tr class="separator:a2af7b9843d4d21b5ba6e0b0ffdf590ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cdc4dd875935cd50b2c18cc7026a63"><td class="memItemLeft" align="right" valign="top"><a id="a79cdc4dd875935cd50b2c18cc7026a63"></a>
typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_amplitude_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:a79cdc4dd875935cd50b2c18cc7026a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e06a518e6e767672065f971466ee75"><td class="memItemLeft" align="right" valign="top"><a id="a46e06a518e6e767672065f971466ee75"></a>
typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_amplitude_avg_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:a46e06a518e6e767672065f971466ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c5d9ad7d459e31a2c6390029cc8ec6"><td class="memItemLeft" align="right" valign="top"><a id="a58c5d9ad7d459e31a2c6390029cc8ec6"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_frequency_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t target_freq_Hz)</td></tr>
<tr class="separator:a58c5d9ad7d459e31a2c6390029cc8ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491a48e6f1324ed5af6943b9d0bf0cbf"><td class="memItemLeft" align="right" valign="top"><a id="a491a48e6f1324ed5af6943b9d0bf0cbf"></a>
typedef uint32_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_frequency_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:a491a48e6f1324ed5af6943b9d0bf0cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15bf208c75e1ef9e971bf721a7b1180"><td class="memItemLeft" align="right" valign="top"><a id="ae15bf208c75e1ef9e971bf721a7b1180"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_iq_data_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *buf_ptr, uint16_t start_sample, uint16_t num_samples, <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a> io_mode)</td></tr>
<tr class="separator:ae15bf208c75e1ef9e971bf721a7b1180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c392ed5b61635845b70f3f062a7130d"><td class="memItemLeft" align="right" valign="top"><a id="a3c392ed5b61635845b70f3f062a7130d"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_amplitude_data_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t *buf_ptr, uint16_t start_sample, uint16_t num_samples, <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a> io_mode)</td></tr>
<tr class="separator:a3c392ed5b61635845b70f3f062a7130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b4f8fd07fe57597cb38651218b70ad"><td class="memItemLeft" align="right" valign="top"><a id="a46b4f8fd07fe57597cb38651218b70ad"></a>
typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_samples_to_mm_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="separator:a46b4f8fd07fe57597cb38651218b70ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed2e03b41bb1bea2ad18358978fb2c0"><td class="memItemLeft" align="right" valign="top"><a id="a9ed2e03b41bb1bea2ad18358978fb2c0"></a>
typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_mm_to_samples_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_mm)</td></tr>
<tr class="separator:a9ed2e03b41bb1bea2ad18358978fb2c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71441eb7d394f189bf0ca20631a3ceb"><td class="memItemLeft" align="right" valign="top"><a id="ac71441eb7d394f189bf0ca20631a3ceb"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_threshold_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t threshold_index, uint16_t amplitude)</td></tr>
<tr class="separator:ac71441eb7d394f189bf0ca20631a3ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf36d2da1dc69f80fd34afd0a19ec901"><td class="memItemLeft" align="right" valign="top"><a id="acf36d2da1dc69f80fd34afd0a19ec901"></a>
typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_threshold_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t threshold_index)</td></tr>
<tr class="separator:acf36d2da1dc69f80fd34afd0a19ec901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8b7fbc50209ff9f2b552c629422ab1"><td class="memItemLeft" align="right" valign="top"><a id="abd8b7fbc50209ff9f2b552c629422ab1"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_thresholds_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__thresholds__t.html">ch_thresholds_t</a> *thresh_ptr)</td></tr>
<tr class="separator:abd8b7fbc50209ff9f2b552c629422ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff965a2c312238832d3555ceb770c5e7"><td class="memItemLeft" align="right" valign="top"><a id="aff965a2c312238832d3555ceb770c5e7"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_thresholds_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__thresholds__t.html">ch_thresholds_t</a> *thresh_ptr)</td></tr>
<tr class="separator:aff965a2c312238832d3555ceb770c5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9f09b5f92ca252c731e032246a7d26"><td class="memItemLeft" align="right" valign="top"><a id="a0d9f09b5f92ca252c731e032246a7d26"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_target_interrupt_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t enable)</td></tr>
<tr class="separator:a0d9f09b5f92ca252c731e032246a7d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dcf9ee0400b13af4a04ae837cb55df6"><td class="memItemLeft" align="right" valign="top"><a id="a2dcf9ee0400b13af4a04ae837cb55df6"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_target_interrupt_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:a2dcf9ee0400b13af4a04ae837cb55df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd801eb0b4aed7f376c000bc898d8baf"><td class="memItemLeft" align="right" valign="top"><a id="acd801eb0b4aed7f376c000bc898d8baf"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_static_range_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t static_range)</td></tr>
<tr class="separator:acd801eb0b4aed7f376c000bc898d8baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffddcde294434163ba97c7ab5a97159"><td class="memItemLeft" align="right" valign="top"><a id="a7ffddcde294434163ba97c7ab5a97159"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_static_coeff_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t static_coeff)</td></tr>
<tr class="separator:a7ffddcde294434163ba97c7ab5a97159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa964c27e0b8e45f4ecc4cd53e6d2d77c"><td class="memItemLeft" align="right" valign="top"><a id="aa964c27e0b8e45f4ecc4cd53e6d2d77c"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_static_coeff_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:aa964c27e0b8e45f4ecc4cd53e6d2d77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d8bec80f85284ec13267357afe6bed"><td class="memItemLeft" align="right" valign="top"><a id="a13d8bec80f85284ec13267357afe6bed"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_rx_holdoff_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t rx_holdoff)</td></tr>
<tr class="separator:a13d8bec80f85284ec13267357afe6bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc33bf5537be0983a09eb876455f68e"><td class="memItemLeft" align="right" valign="top"><a id="a6bc33bf5537be0983a09eb876455f68e"></a>
typedef uint16_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_rx_holdoff_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:a6bc33bf5537be0983a09eb876455f68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e19f6e5672bcc59711d02fa48c4dab8"><td class="memItemLeft" align="right" valign="top"><a id="a2e19f6e5672bcc59711d02fa48c4dab8"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_tx_length_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t tx_length)</td></tr>
<tr class="separator:a2e19f6e5672bcc59711d02fa48c4dab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3cc28504ac0204bd0f5a51db2599f5"><td class="memItemLeft" align="right" valign="top"><a id="acb3cc28504ac0204bd0f5a51db2599f5"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_tx_length_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:acb3cc28504ac0204bd0f5a51db2599f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f66d4f05322de3a58390ddceb51364c"><td class="memItemLeft" align="right" valign="top"><a id="a2f66d4f05322de3a58390ddceb51364c"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_rx_pulse_length_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:a2f66d4f05322de3a58390ddceb51364c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae6f5c3116c1830cd5b0442a34baa2b"><td class="memItemLeft" align="right" valign="top"><a id="a3ae6f5c3116c1830cd5b0442a34baa2b"></a>
typedef uint8_t(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_set_time_plan_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a23d84a030c9fc403cb538f5d0c3f3a52">ch_time_plan_t</a> time_plan)</td></tr>
<tr class="separator:a3ae6f5c3116c1830cd5b0442a34baa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0c70f0ef32706c289c5b07fc67e0b5"><td class="memItemLeft" align="right" valign="top"><a id="afa0c70f0ef32706c289c5b07fc67e0b5"></a>
typedef <a class="el" href="soniclib_8h.html#a23d84a030c9fc403cb538f5d0c3f3a52">ch_time_plan_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>ch_get_time_plan_func_t</b>) (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="separator:afa0c70f0ef32706c289c5b07fc67e0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c068c499b8a0c1069751041444da20"><td class="memItemLeft" align="right" valign="top"><a id="a58c068c499b8a0c1069751041444da20"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a58c068c499b8a0c1069751041444da20">ch_io_int_callback_t</a>) (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t io_index)</td></tr>
<tr class="memdesc:a58c068c499b8a0c1069751041444da20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data-ready interrupt callback routine pointer. <br /></td></tr>
<tr class="separator:a58c068c499b8a0c1069751041444da20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e3bc51c237abf8b03ce396db3f7caf"><td class="memItemLeft" align="right" valign="top"><a id="a98e3bc51c237abf8b03ce396db3f7caf"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a98e3bc51c237abf8b03ce396db3f7caf">ch_io_complete_callback_t</a>) (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a98e3bc51c237abf8b03ce396db3f7caf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-blocking I/O complete callback routine pointer. <br /></td></tr>
<tr class="separator:a98e3bc51c237abf8b03ce396db3f7caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e5a58672f5728ead1a7b43ed248841"><td class="memItemLeft" align="right" valign="top"><a id="aa0e5a58672f5728ead1a7b43ed248841"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#aa0e5a58672f5728ead1a7b43ed248841">ch_timer_callback_t</a>) (void)</td></tr>
<tr class="memdesc:aa0e5a58672f5728ead1a7b43ed248841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Periodic timer callback routine pointer. <br /></td></tr>
<tr class="separator:aa0e5a58672f5728ead1a7b43ed248841"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a76e2eec311d22ca2a8a5b89348c95a8f"><td class="memItemLeft" align="right" valign="top"><a id="a76e2eec311d22ca2a8a5b89348c95a8f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a76e2eec311d22ca2a8a5b89348c95a8f">ch_retval</a> { <b>RET_OK</b> = 0, 
<b>RET_ERR</b> = 1
 }</td></tr>
<tr class="memdesc:a76e2eec311d22ca2a8a5b89348c95a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return value codes. <br /></td></tr>
<tr class="separator:a76e2eec311d22ca2a8a5b89348c95a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b137d77afad79d536e322eacdfebd0c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0c">ch_range_t</a> { <a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0cac6b9feacfe2dfe9809e4a1aeb5e98666">CH_RANGE_ECHO_ONE_WAY</a> = 0, 
<a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0ca3e14ab78ba174bd7883799b0fb5cbbcf">CH_RANGE_ECHO_ROUND_TRIP</a> = 1, 
<a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0ca19a564606f15f72986b0912156cce533">CH_RANGE_DIRECT</a> = 2
 }</td></tr>
<tr class="memdesc:a1b137d77afad79d536e322eacdfebd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range data types.  <a href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0c">More...</a><br /></td></tr>
<tr class="separator:a1b137d77afad79d536e322eacdfebd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da193cf2f2476d27fd7ceb533f8cdc4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a> { <a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4ae0c08b8a3177f79eeb861205c7dac1f1">CH_MODE_IDLE</a> = 0x00, 
<a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4aaf3c359ba59ec257f215b09ad9d98248">CH_MODE_FREERUN</a> = 0x02, 
<a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4ab4ab53a6ca9bbf9c090e07b3e69d5c0e">CH_MODE_TRIGGERED_TX_RX</a> = 0x10, 
<a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4a78858c96eade25f0eee8dfcf7a629d01">CH_MODE_TRIGGERED_RX_ONLY</a> = 0x20
 }</td></tr>
<tr class="memdesc:a0da193cf2f2476d27fd7ceb533f8cdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor operating modes.  <a href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">More...</a><br /></td></tr>
<tr class="separator:a0da193cf2f2476d27fd7ceb533f8cdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada69fa98b2d110de6d1070c5150f8113"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a> { <a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113a7d47de24ba2696e1c1d5ad52b4ba2f84">CH_RESET_HARD</a> = 0, 
<a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113a148a4819dbb2953a7a78b14e24efe6c0">CH_RESET_SOFT</a> = 1
 }</td></tr>
<tr class="memdesc:ada69fa98b2d110de6d1070c5150f8113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sensor reset types.  <a href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">More...</a><br /></td></tr>
<tr class="separator:ada69fa98b2d110de6d1070c5150f8113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b7f8516a2c66f0ccc72704f7d5d94a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a> { <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94aa7a046d9f4e299da922c6f5e80bdbb4b8">CH_IO_MODE_BLOCK</a> = 0, 
<a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94aa76c5fc9482109b8302837d621d58a833">CH_IO_MODE_NONBLOCK</a> = 1
 }</td></tr>
<tr class="memdesc:a66b7f8516a2c66f0ccc72704f7d5d94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">I/O blocking mode flags.  <a href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">More...</a><br /></td></tr>
<tr class="separator:a66b7f8516a2c66f0ccc72704f7d5d94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d84a030c9fc403cb538f5d0c3f3a52"><td class="memItemLeft" align="right" valign="top"><a id="a23d84a030c9fc403cb538f5d0c3f3a52"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a23d84a030c9fc403cb538f5d0c3f3a52">ch_time_plan_t</a> { <b>CH_TIME_PLAN_1</b> = 0, 
<b>CH_TIME_PLAN_2</b> = 1, 
<b>CH_TIME_PLAN_3</b> = 2, 
<b>CH_TIME_PLAN_NONE</b> = 255
 }</td></tr>
<tr class="memdesc:a23d84a030c9fc403cb538f5d0c3f3a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Time plan. <br /></td></tr>
<tr class="separator:a23d84a030c9fc403cb538f5d0c3f3a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afb33f776f4a2d55c885023798402c2a5"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5">ch_init</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num, <a class="el" href="soniclib_8h.html#a4e9d2049253328d1a1c57458a70d29e9">ch_fw_init_func_t</a> fw_init_func)</td></tr>
<tr class="memdesc:afb33f776f4a2d55c885023798402c2a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the device descriptor for a sensor.  <a href="#afb33f776f4a2d55c885023798402c2a5">More...</a><br /></td></tr>
<tr class="separator:afb33f776f4a2d55c885023798402c2a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1acc5372d38d7abd7028a5504e5634"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634">ch_group_start</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:a3d1acc5372d38d7abd7028a5504e5634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Program and start a group of sensors.  <a href="#a3d1acc5372d38d7abd7028a5504e5634">More...</a><br /></td></tr>
<tr class="separator:a3d1acc5372d38d7abd7028a5504e5634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2047b5e506b99131585bcfb4ce37b4ac"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a2047b5e506b99131585bcfb4ce37b4ac">ch_get_config</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__config__t.html">ch_config_t</a> *config_ptr)</td></tr>
<tr class="memdesc:a2047b5e506b99131585bcfb4ce37b4ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current configuration settings for a sensor.  <a href="#a2047b5e506b99131585bcfb4ce37b4ac">More...</a><br /></td></tr>
<tr class="separator:a2047b5e506b99131585bcfb4ce37b4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210dcd310e0c16c343f11c2e3c53984f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a210dcd310e0c16c343f11c2e3c53984f">ch_set_config</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__config__t.html">ch_config_t</a> *config_ptr)</td></tr>
<tr class="memdesc:a210dcd310e0c16c343f11c2e3c53984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple configuration settings for a sensor.  <a href="#a210dcd310e0c16c343f11c2e3c53984f">More...</a><br /></td></tr>
<tr class="separator:a210dcd310e0c16c343f11c2e3c53984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5083e622e8cc3852a4193f6d8dce9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ade5083e622e8cc3852a4193f6d8dce9c">ch_trigger</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ade5083e622e8cc3852a4193f6d8dce9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a measurement on one sensor.  <a href="#ade5083e622e8cc3852a4193f6d8dce9c">More...</a><br /></td></tr>
<tr class="separator:ade5083e622e8cc3852a4193f6d8dce9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e917eea19df611680dc97e2401db3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#aa4e917eea19df611680dc97e2401db3a">ch_group_trigger</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:aa4e917eea19df611680dc97e2401db3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trigger a measurement on a group of sensors.  <a href="#aa4e917eea19df611680dc97e2401db3a">More...</a><br /></td></tr>
<tr class="separator:aa4e917eea19df611680dc97e2401db3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38861d5f023ea837a9ee15bdca5fa114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a38861d5f023ea837a9ee15bdca5fa114">ch_reset</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a> reset_type)</td></tr>
<tr class="memdesc:a38861d5f023ea837a9ee15bdca5fa114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a sensor.  <a href="#a38861d5f023ea837a9ee15bdca5fa114">More...</a><br /></td></tr>
<tr class="separator:a38861d5f023ea837a9ee15bdca5fa114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c386c49a6c8ad4bb506c4d00e3bcf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a63c386c49a6c8ad4bb506c4d00e3bcf5">ch_group_reset</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a> reset_type)</td></tr>
<tr class="memdesc:a63c386c49a6c8ad4bb506c4d00e3bcf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a group of sensors.  <a href="#a63c386c49a6c8ad4bb506c4d00e3bcf5">More...</a><br /></td></tr>
<tr class="separator:a63c386c49a6c8ad4bb506c4d00e3bcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea97825e46bd60eeb79cd5a155f80d0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a1ea97825e46bd60eeb79cd5a155f80d0">ch_sensor_is_connected</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a1ea97825e46bd60eeb79cd5a155f80d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if a sensor is connected.  <a href="#a1ea97825e46bd60eeb79cd5a155f80d0">More...</a><br /></td></tr>
<tr class="separator:a1ea97825e46bd60eeb79cd5a155f80d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57e731b7b145a37aa7685a2fbe320c9"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ad57e731b7b145a37aa7685a2fbe320c9">ch_get_part_number</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ad57e731b7b145a37aa7685a2fbe320c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get part number for a sensor.  <a href="#ad57e731b7b145a37aa7685a2fbe320c9">More...</a><br /></td></tr>
<tr class="separator:ad57e731b7b145a37aa7685a2fbe320c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775e8fcdd9f1c1fa3dd90d87024101ab"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a775e8fcdd9f1c1fa3dd90d87024101ab">ch_get_dev_num</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a775e8fcdd9f1c1fa3dd90d87024101ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device number (I/O index values) for a sensor.  <a href="#a775e8fcdd9f1c1fa3dd90d87024101ab">More...</a><br /></td></tr>
<tr class="separator:a775e8fcdd9f1c1fa3dd90d87024101ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703c36ef2e38b7f9274c8e05a5109d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a703c36ef2e38b7f9274c8e05a5109d72">ch_get_dev_ptr</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t dev_num)</td></tr>
<tr class="memdesc:a703c36ef2e38b7f9274c8e05a5109d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get device descriptor pointer for a sensor.  <a href="#a703c36ef2e38b7f9274c8e05a5109d72">More...</a><br /></td></tr>
<tr class="separator:a703c36ef2e38b7f9274c8e05a5109d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a95de2412e067451248211003e1240"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ae0a95de2412e067451248211003e1240">ch_get_num_ports</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:ae0a95de2412e067451248211003e1240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the total number of sensor ports (possible sensors) in a sensor group.  <a href="#ae0a95de2412e067451248211003e1240">More...</a><br /></td></tr>
<tr class="separator:ae0a95de2412e067451248211003e1240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5496937b5fae4e2c04ff2fa23ed9fbf"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ab5496937b5fae4e2c04ff2fa23ed9fbf">ch_get_i2c_address</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ab5496937b5fae4e2c04ff2fa23ed9fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active I2C address for a sensor.  <a href="#ab5496937b5fae4e2c04ff2fa23ed9fbf">More...</a><br /></td></tr>
<tr class="separator:ab5496937b5fae4e2c04ff2fa23ed9fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188023bdbeb0928f77a51a6ca5d254e9"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a188023bdbeb0928f77a51a6ca5d254e9">ch_get_i2c_bus</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a188023bdbeb0928f77a51a6ca5d254e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the active I2C bus for a sensor.  <a href="#a188023bdbeb0928f77a51a6ca5d254e9">More...</a><br /></td></tr>
<tr class="separator:a188023bdbeb0928f77a51a6ca5d254e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a2126fda5645c1be134c2187cac61f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ac4a2126fda5645c1be134c2187cac61f">ch_get_fw_version_string</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ac4a2126fda5645c1be134c2187cac61f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the firmware version description string for a sensor.  <a href="#ac4a2126fda5645c1be134c2187cac61f">More...</a><br /></td></tr>
<tr class="separator:ac4a2126fda5645c1be134c2187cac61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd52987d0cfca5d0dec4f962ce15995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#acbd52987d0cfca5d0dec4f962ce15995">ch_get_mode</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:acbd52987d0cfca5d0dec4f962ce15995"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current operating mode for a sensor.  <a href="#acbd52987d0cfca5d0dec4f962ce15995">More...</a><br /></td></tr>
<tr class="separator:acbd52987d0cfca5d0dec4f962ce15995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af427c34df885a028ee0f7cdddc981001"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#af427c34df885a028ee0f7cdddc981001">ch_set_mode</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a> mode)</td></tr>
<tr class="memdesc:af427c34df885a028ee0f7cdddc981001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure a sensor for the specified operating mode.  <a href="#af427c34df885a028ee0f7cdddc981001">More...</a><br /></td></tr>
<tr class="separator:af427c34df885a028ee0f7cdddc981001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973ae35d4ac7064704da5bcf2d05f6ef"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a973ae35d4ac7064704da5bcf2d05f6ef">ch_get_sample_interval</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a973ae35d4ac7064704da5bcf2d05f6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the internal sample timing interval for a sensor.  <a href="#a973ae35d4ac7064704da5bcf2d05f6ef">More...</a><br /></td></tr>
<tr class="separator:a973ae35d4ac7064704da5bcf2d05f6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a08fc3bf063f817bb28cd666d19fa2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ae3a08fc3bf063f817bb28cd666d19fa2">ch_set_sample_interval</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t interval_ms)</td></tr>
<tr class="memdesc:ae3a08fc3bf063f817bb28cd666d19fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the internal sample interval for a sensor in freerunning mode.  <a href="#ae3a08fc3bf063f817bb28cd666d19fa2">More...</a><br /></td></tr>
<tr class="separator:ae3a08fc3bf063f817bb28cd666d19fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53cba94e769a33dfd290555efb412dda"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda">ch_get_num_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a53cba94e769a33dfd290555efb412dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of samples per measurement cycle.  <a href="#a53cba94e769a33dfd290555efb412dda">More...</a><br /></td></tr>
<tr class="separator:a53cba94e769a33dfd290555efb412dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a92fdea71bf1aff4b05891a933a5e84"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a8a92fdea71bf1aff4b05891a933a5e84">ch_set_num_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="memdesc:a8a92fdea71bf1aff4b05891a933a5e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sensor sample count directly.  <a href="#a8a92fdea71bf1aff4b05891a933a5e84">More...</a><br /></td></tr>
<tr class="separator:a8a92fdea71bf1aff4b05891a933a5e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb50e63f45eee386a19cd9ef12c8de6"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a7eb50e63f45eee386a19cd9ef12c8de6">ch_get_max_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a7eb50e63f45eee386a19cd9ef12c8de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum possible sample count per measurement.  <a href="#a7eb50e63f45eee386a19cd9ef12c8de6">More...</a><br /></td></tr>
<tr class="separator:a7eb50e63f45eee386a19cd9ef12c8de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b6bb2df00b9feb43955902c55835f7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a96b6bb2df00b9feb43955902c55835f7">ch_get_max_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a96b6bb2df00b9feb43955902c55835f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum range setting for a sensor.  <a href="#a96b6bb2df00b9feb43955902c55835f7">More...</a><br /></td></tr>
<tr class="separator:a96b6bb2df00b9feb43955902c55835f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a264ebc25b13778176e83c0c910997"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997">ch_set_max_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t max_range)</td></tr>
<tr class="memdesc:a41a264ebc25b13778176e83c0c910997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum range for a sensor.  <a href="#a41a264ebc25b13778176e83c0c910997">More...</a><br /></td></tr>
<tr class="separator:a41a264ebc25b13778176e83c0c910997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c552c6a09c2400766ee329efcaeaa1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a56c552c6a09c2400766ee329efcaeaa1">ch_get_sample_window</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t *start_sample_ptr, uint16_t *num_samples_ptr)</td></tr>
<tr class="memdesc:a56c552c6a09c2400766ee329efcaeaa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sample window for amplitude averaging.  <a href="#a56c552c6a09c2400766ee329efcaeaa1">More...</a><br /></td></tr>
<tr class="separator:a56c552c6a09c2400766ee329efcaeaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183c63e3d6794848986656895b918d10"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a183c63e3d6794848986656895b918d10">ch_set_sample_window</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t start_sample, uint16_t num_samples)</td></tr>
<tr class="memdesc:a183c63e3d6794848986656895b918d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sample window for amplitude averaging.  <a href="#a183c63e3d6794848986656895b918d10">More...</a><br /></td></tr>
<tr class="separator:a183c63e3d6794848986656895b918d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b0b54393d6373c0f1c3db35d7f1cd8"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ad7b0b54393d6373c0f1c3db35d7f1cd8">ch_get_static_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ad7b0b54393d6373c0f1c3db35d7f1cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get static target rejection range setting.  <a href="#ad7b0b54393d6373c0f1c3db35d7f1cd8">More...</a><br /></td></tr>
<tr class="separator:ad7b0b54393d6373c0f1c3db35d7f1cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b5aecb6cfe54c6d2df428e26192d9a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ab7b5aecb6cfe54c6d2df428e26192d9a">ch_set_static_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="memdesc:ab7b5aecb6cfe54c6d2df428e26192d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure static target rejection.  <a href="#ab7b5aecb6cfe54c6d2df428e26192d9a">More...</a><br /></td></tr>
<tr class="separator:ab7b5aecb6cfe54c6d2df428e26192d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb4847d39cc9418373b6d1ac8dadc6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6">ch_get_range</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0c">ch_range_t</a> range_type)</td></tr>
<tr class="memdesc:a5cbb4847d39cc9418373b6d1ac8dadc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measured range from a sensor.  <a href="#a5cbb4847d39cc9418373b6d1ac8dadc6">More...</a><br /></td></tr>
<tr class="separator:a5cbb4847d39cc9418373b6d1ac8dadc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c05a1edba09919240c5d3db8f5a882b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a3c05a1edba09919240c5d3db8f5a882b">ch_get_tof_tick</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t timer_freq)</td></tr>
<tr class="memdesc:a3c05a1edba09919240c5d3db8f5a882b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measured Time-of-flight from a sensor in the ultrasound periodic timer tick.  <a href="#a3c05a1edba09919240c5d3db8f5a882b">More...</a><br /></td></tr>
<tr class="separator:a3c05a1edba09919240c5d3db8f5a882b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ef517f154bb269d31fdf3f4e0cc7a2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#aa2ef517f154bb269d31fdf3f4e0cc7a2">ch_get_amplitude</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aa2ef517f154bb269d31fdf3f4e0cc7a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the measured amplitude from a sensor.  <a href="#aa2ef517f154bb269d31fdf3f4e0cc7a2">More...</a><br /></td></tr>
<tr class="separator:aa2ef517f154bb269d31fdf3f4e0cc7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd6ee85a061f71da4e98aab683fef5b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#aecd6ee85a061f71da4e98aab683fef5b">ch_get_amplitude_avg</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aecd6ee85a061f71da4e98aab683fef5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the averaged measured amplitude over the sample window.  <a href="#aecd6ee85a061f71da4e98aab683fef5b">More...</a><br /></td></tr>
<tr class="separator:aecd6ee85a061f71da4e98aab683fef5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6216f922775cbf3c571734e5287d50"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a4d6216f922775cbf3c571734e5287d50">ch_get_bandwidth</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a4d6216f922775cbf3c571734e5287d50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the bandwidth of a sensor.  <a href="#a4d6216f922775cbf3c571734e5287d50">More...</a><br /></td></tr>
<tr class="separator:a4d6216f922775cbf3c571734e5287d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff28a47fdf01cc9f893b85a900db145"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a3ff28a47fdf01cc9f893b85a900db145">ch_set_frequency</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint32_t target_freq_Hz)</td></tr>
<tr class="memdesc:a3ff28a47fdf01cc9f893b85a900db145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the operating frequency of a sensor.  <a href="#a3ff28a47fdf01cc9f893b85a900db145">More...</a><br /></td></tr>
<tr class="separator:a3ff28a47fdf01cc9f893b85a900db145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae60d24c0b1d0fb5f06e2449c0fa149"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a7ae60d24c0b1d0fb5f06e2449c0fa149">ch_get_frequency</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a7ae60d24c0b1d0fb5f06e2449c0fa149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the operating frequency of a sensor.  <a href="#a7ae60d24c0b1d0fb5f06e2449c0fa149">More...</a><br /></td></tr>
<tr class="separator:a7ae60d24c0b1d0fb5f06e2449c0fa149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa365c564c65b5aa97ca9dca28711807b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#aa365c564c65b5aa97ca9dca28711807b">ch_get_rtc_cal_result</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:aa365c564c65b5aa97ca9dca28711807b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real-time clock calibration value.  <a href="#aa365c564c65b5aa97ca9dca28711807b">More...</a><br /></td></tr>
<tr class="separator:aa365c564c65b5aa97ca9dca28711807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1629cdf88732e9e3d4bfbe422900220"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#af1629cdf88732e9e3d4bfbe422900220">ch_get_rtc_cal_pulselength</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:af1629cdf88732e9e3d4bfbe422900220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the real-time clock calibration pulse length.  <a href="#af1629cdf88732e9e3d4bfbe422900220">More...</a><br /></td></tr>
<tr class="separator:af1629cdf88732e9e3d4bfbe422900220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88053b2f8918538fc3c2c8681e4269b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ab88053b2f8918538fc3c2c8681e4269b">ch_get_scale_factor</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ab88053b2f8918538fc3c2c8681e4269b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the calibration scale factor of a sensor.  <a href="#ab88053b2f8918538fc3c2c8681e4269b">More...</a><br /></td></tr>
<tr class="separator:ab88053b2f8918538fc3c2c8681e4269b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acde1c47209421107f576b7e01b6fa5e8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8">ch_get_iq_data</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *buf_ptr, uint16_t start_sample, uint16_t num_samples, <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a> mode)</td></tr>
<tr class="memdesc:acde1c47209421107f576b7e01b6fa5e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw I/Q measurement data from a sensor.  <a href="#acde1c47209421107f576b7e01b6fa5e8">More...</a><br /></td></tr>
<tr class="separator:acde1c47209421107f576b7e01b6fa5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95998b37600ae7ef3a2300c10519fdf"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#af95998b37600ae7ef3a2300c10519fdf">ch_get_amplitude_data</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t *buf_ptr, uint16_t start_sample, uint16_t num_samples, <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a> mode)</td></tr>
<tr class="memdesc:af95998b37600ae7ef3a2300c10519fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the raw amplitude measurement data from a sensor.  <a href="#af95998b37600ae7ef3a2300c10519fdf">More...</a><br /></td></tr>
<tr class="separator:af95998b37600ae7ef3a2300c10519fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290f3e5de2ee174e37ff4522df51d376"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a290f3e5de2ee174e37ff4522df51d376">ch_samples_to_mm</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="memdesc:a290f3e5de2ee174e37ff4522df51d376"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert sample count to millimeters for a sensor.  <a href="#a290f3e5de2ee174e37ff4522df51d376">More...</a><br /></td></tr>
<tr class="separator:a290f3e5de2ee174e37ff4522df51d376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa256c720961a6d327c515da60d8071c2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2">ch_mm_to_samples</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_mm)</td></tr>
<tr class="memdesc:aa256c720961a6d327c515da60d8071c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert millimeters to sample count for a sensor.  <a href="#aa256c720961a6d327c515da60d8071c2">More...</a><br /></td></tr>
<tr class="separator:aa256c720961a6d327c515da60d8071c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c53aa278150f204d7dd4eaef3cbb95"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a21c53aa278150f204d7dd4eaef3cbb95">ch_iq_to_amplitude</a> (<a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *iq_sample_ptr)</td></tr>
<tr class="memdesc:a21c53aa278150f204d7dd4eaef3cbb95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate amplitude from sample I/Q values.  <a href="#a21c53aa278150f204d7dd4eaef3cbb95">More...</a><br /></td></tr>
<tr class="separator:a21c53aa278150f204d7dd4eaef3cbb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b5f63c32c49bf634a00fc6594e57bc"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#af7b5f63c32c49bf634a00fc6594e57bc">ch_io_start_nb</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr)</td></tr>
<tr class="memdesc:af7b5f63c32c49bf634a00fc6594e57bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start non-blocking I/O operation(s) for a group of sensors.  <a href="#af7b5f63c32c49bf634a00fc6594e57bc">More...</a><br /></td></tr>
<tr class="separator:af7b5f63c32c49bf634a00fc6594e57bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d4045f3510d82596c8231123e890b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#af3d4045f3510d82596c8231123e890b9">ch_io_int_callback_set</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="soniclib_8h.html#a58c068c499b8a0c1069751041444da20">ch_io_int_callback_t</a> callback_func_ptr)</td></tr>
<tr class="memdesc:af3d4045f3510d82596c8231123e890b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register sensor interrupt callback routine for a group of sensors.  <a href="#af3d4045f3510d82596c8231123e890b9">More...</a><br /></td></tr>
<tr class="separator:af3d4045f3510d82596c8231123e890b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40302a26ef7dd9868f5c28bcfc15cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea">ch_io_complete_callback_set</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, <a class="el" href="soniclib_8h.html#a98e3bc51c237abf8b03ce396db3f7caf">ch_io_complete_callback_t</a> callback_func_ptr)</td></tr>
<tr class="memdesc:ae40302a26ef7dd9868f5c28bcfc15cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register non-blocking I/O complete callback routine for a group of sensors.  <a href="#ae40302a26ef7dd9868f5c28bcfc15cea">More...</a><br /></td></tr>
<tr class="separator:ae40302a26ef7dd9868f5c28bcfc15cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b5931001ef934347a12daa46d700a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a32b5931001ef934347a12daa46d700a7">ch_io_notify</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t i2c_bus_index)</td></tr>
<tr class="memdesc:a32b5931001ef934347a12daa46d700a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify SonicLib that a non-blocking I/O operation has completed.  <a href="#a32b5931001ef934347a12daa46d700a7">More...</a><br /></td></tr>
<tr class="separator:a32b5931001ef934347a12daa46d700a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05448e0cd2c7bd018c6ca10d29aa5673"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a05448e0cd2c7bd018c6ca10d29aa5673">ch_get_threshold</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t threshold_index)</td></tr>
<tr class="memdesc:a05448e0cd2c7bd018c6ca10d29aa5673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the detection threshold.  <a href="#a05448e0cd2c7bd018c6ca10d29aa5673">More...</a><br /></td></tr>
<tr class="separator:a05448e0cd2c7bd018c6ca10d29aa5673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221935be365b6c9fa5b2711c7df57750"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a221935be365b6c9fa5b2711c7df57750">ch_set_threshold</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t threshold_index, uint16_t amplitude)</td></tr>
<tr class="memdesc:a221935be365b6c9fa5b2711c7df57750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the detection threshold.  <a href="#a221935be365b6c9fa5b2711c7df57750">More...</a><br /></td></tr>
<tr class="separator:a221935be365b6c9fa5b2711c7df57750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea0971363f3a1c9fdc7e8f040489edd"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a9ea0971363f3a1c9fdc7e8f040489edd">ch_get_thresholds</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__thresholds__t.html">ch_thresholds_t</a> *thresh_ptr)</td></tr>
<tr class="memdesc:a9ea0971363f3a1c9fdc7e8f040489edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get detection thresholds (CH201 only).  <a href="#a9ea0971363f3a1c9fdc7e8f040489edd">More...</a><br /></td></tr>
<tr class="separator:a9ea0971363f3a1c9fdc7e8f040489edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e948bfbdc2cbca2f04bc97459541e5f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a7e948bfbdc2cbca2f04bc97459541e5f">ch_set_thresholds</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="structch__thresholds__t.html">ch_thresholds_t</a> *thresh_ptr)</td></tr>
<tr class="memdesc:a7e948bfbdc2cbca2f04bc97459541e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set detection thresholds (CH201 only).  <a href="#a7e948bfbdc2cbca2f04bc97459541e5f">More...</a><br /></td></tr>
<tr class="separator:a7e948bfbdc2cbca2f04bc97459541e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b75d1339613e2f899d1b3b19933d245"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a5b75d1339613e2f899d1b3b19933d245">ch_set_target_interrupt</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t enable)</td></tr>
<tr class="memdesc:a5b75d1339613e2f899d1b3b19933d245"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set target detection interrupt mode.  <a href="#a5b75d1339613e2f899d1b3b19933d245">More...</a><br /></td></tr>
<tr class="separator:a5b75d1339613e2f899d1b3b19933d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f37dcc63627f500f808fbe150fd9b89"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a5f37dcc63627f500f808fbe150fd9b89">ch_get_target_interrupt</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a5f37dcc63627f500f808fbe150fd9b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the target detection interrupt mode setting.  <a href="#a5f37dcc63627f500f808fbe150fd9b89">More...</a><br /></td></tr>
<tr class="separator:a5f37dcc63627f500f808fbe150fd9b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872db7bc23cd2a4d2f1abe5e7551a484"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a872db7bc23cd2a4d2f1abe5e7551a484">ch_set_static_coeff</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t static_coeff)</td></tr>
<tr class="memdesc:a872db7bc23cd2a4d2f1abe5e7551a484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the static coefficient for IIR filter.  <a href="#a872db7bc23cd2a4d2f1abe5e7551a484">More...</a><br /></td></tr>
<tr class="separator:a872db7bc23cd2a4d2f1abe5e7551a484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7667d98222225444cc20a66649bbb36c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a7667d98222225444cc20a66649bbb36c">ch_get_static_coeff</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a7667d98222225444cc20a66649bbb36c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the static coefficient for IIR filter.  <a href="#a7667d98222225444cc20a66649bbb36c">More...</a><br /></td></tr>
<tr class="separator:a7667d98222225444cc20a66649bbb36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2f18445966ba0094e54bfdae39bc0a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a4d2f18445966ba0094e54bfdae39bc0a">ch_set_rx_holdoff</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint16_t num_samples)</td></tr>
<tr class="memdesc:a4d2f18445966ba0094e54bfdae39bc0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the receive holdoff sample count.  <a href="#a4d2f18445966ba0094e54bfdae39bc0a">More...</a><br /></td></tr>
<tr class="separator:a4d2f18445966ba0094e54bfdae39bc0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d5ac02276e0d9b77549eb29195d6c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#ab71d5ac02276e0d9b77549eb29195d6c">ch_get_rx_holdoff</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:ab71d5ac02276e0d9b77549eb29195d6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the receive holdoff sample count.  <a href="#ab71d5ac02276e0d9b77549eb29195d6c">More...</a><br /></td></tr>
<tr class="separator:ab71d5ac02276e0d9b77549eb29195d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501202a29786cb0457a244d0b0c42f23"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a501202a29786cb0457a244d0b0c42f23">ch_set_tx_length</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, uint8_t tx_length)</td></tr>
<tr class="memdesc:a501202a29786cb0457a244d0b0c42f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the TX length.  <a href="#a501202a29786cb0457a244d0b0c42f23">More...</a><br /></td></tr>
<tr class="separator:a501202a29786cb0457a244d0b0c42f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da9e8a079f9df8b2e250461bddb3b76"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a1da9e8a079f9df8b2e250461bddb3b76">ch_get_tx_length</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a1da9e8a079f9df8b2e250461bddb3b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the TX length.  <a href="#a1da9e8a079f9df8b2e250461bddb3b76">More...</a><br /></td></tr>
<tr class="separator:a1da9e8a079f9df8b2e250461bddb3b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb39266281e4aa908a2e57565a95696"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a0cb39266281e4aa908a2e57565a95696">ch_get_rx_pulse_length</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a0cb39266281e4aa908a2e57565a95696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the detected length of the received pulse.  <a href="#a0cb39266281e4aa908a2e57565a95696">More...</a><br /></td></tr>
<tr class="separator:a0cb39266281e4aa908a2e57565a95696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521bfb331d13a9fa2cdfecf909038c92"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a521bfb331d13a9fa2cdfecf909038c92">ch_set_time_plan</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr, <a class="el" href="soniclib_8h.html#a23d84a030c9fc403cb538f5d0c3f3a52">ch_time_plan_t</a> time_plan)</td></tr>
<tr class="memdesc:a521bfb331d13a9fa2cdfecf909038c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure sonicsync timing plan.  <a href="#a521bfb331d13a9fa2cdfecf909038c92">More...</a><br /></td></tr>
<tr class="separator:a521bfb331d13a9fa2cdfecf909038c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f2a32508f42eef57521790587023e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="soniclib_8h.html#a23d84a030c9fc403cb538f5d0c3f3a52">ch_time_plan_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#a38f2a32508f42eef57521790587023e6">ch_get_time_plan</a> (<a class="el" href="structch__dev__t.html">ch_dev_t</a> *dev_ptr)</td></tr>
<tr class="memdesc:a38f2a32508f42eef57521790587023e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read sonicsync timing plan.  <a href="#a38f2a32508f42eef57521790587023e6">More...</a><br /></td></tr>
<tr class="separator:a38f2a32508f42eef57521790587023e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0bbd8d9e2d5e1064fa8eb9ace180f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="soniclib_8h.html#aee0bbd8d9e2d5e1064fa8eb9ace180f7">ch_set_rx_pretrigger</a> (<a class="el" href="structch__group__t.html">ch_group_t</a> *grp_ptr, uint8_t enable)</td></tr>
<tr class="memdesc:aee0bbd8d9e2d5e1064fa8eb9ace180f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable receive-only sensor pre-triggering.  <a href="#aee0bbd8d9e2d5e1064fa8eb9ace180f7">More...</a><br /></td></tr>
<tr class="separator:aee0bbd8d9e2d5e1064fa8eb9ace180f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Chirp SonicLib public API and support functions for Chirp ultrasonic sensors. </p>
<p>Chirp SonicLib is a set of API functions and sensor driver routines designed to easily control Chirp ultrasonic sensors from an embedded C application. It allows an application developer to obtain ultrasonic range data from one or more devices, without needing to develop special low-level code to interact with the sensors directly.</p>
<p>The SonicLib API functions provide a consistent interface for an application to use Chirp sensors in various situations. This is especially important, because all Chirp sensors are completely programmable, including the register map. The SonicLib interfaces allow an application to use new Chirp sensor firmware images, without requiring code changes. Only a single initialization parameter must be modified to use the new sensor firmware.</p>
<dl class="section note"><dt>Note</dt><dd>All operation of the sensor is controlled through the set of functions, data structures, and symbolic values defined in this header file. You should not need to modify this file or the SonicLib functions, or use lower-level internal functions such as described in the <a class="el" href="ch__driver_8h.html" title="Internal driver functions for operation with the Chirp ultrasonic sensor. ">ch_driver.h</a> file. Using any of these non-public methods will reduce your ability to benefit from future enhancements and releases from Chirp.</dd></dl>
<h4>Board Support Package</h4>
<p>SonicLib also defines a set of board support package (BSP) functions that must be provided by the developer, board vendor, or Chirp. The BSP functions are NOT part of SonicLib - they are external interface routines that allow the SonicLib functions to access the peripherals on the target board. These functions, which all begin with a "chbsp_" prefix, are described in the <a class="el" href="chirp__bsp_8h.html" title="User-supplied board support package functions to interface Chirp SonicLib to a specific hardware plat...">chirp_bsp.h</a> header file. See the descriptions in that file for more detailed information on the BSP interfaces.</p>
<p>The BSP also provides the required <em>chirp_board_config.h</em> header file, which contains definitions of how many (possible) sensors and I2C buses are present on the board. These values are used for static array allocations in SonicLib.</p>
<h4>Basic Operating Sequence</h4>
<p>At a high level, an application using SonicLib will do the following:</p><ol type="1">
<li>Initialize the hardware on the board, by calling the BSP's <em><a class="el" href="chirp__bsp_8h.html#a1af911fb2af6031340dc1ffd93449a57" title="Main hardware initialization. ">chbsp_board_init()</a></em> function.</li>
<li>Initialize the SonicLib data structures, by calling <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor. ">ch_init()</a></em> for each sensor.</li>
<li>Program and start the sensor(s), by calling <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors. ">ch_group_start()</a></em>.</li>
<li>Set up a handler function to process interrupts from the sensor.</li>
<li>Set up a triggering mechanism using a board timer, using <em><a class="el" href="chirp__bsp_8h.html#a6034ec7104cb46f2bf6fe4a040a902c2" title="Initialize periodic timer. ">chbsp_periodic_timer_init()</a></em> etc., (unless the sensor will be used in free-running mode, in which no external trigger is needed). A timer handler routine will typically trigger the sensor(s) using <em><a class="el" href="soniclib_8h.html#aa4e917eea19df611680dc97e2401db3a" title="Trigger a measurement on a group of sensors. ">ch_group_trigger()</a></em>.</li>
<li>Configure the sensor's operating mode and range, using <em><a class="el" href="soniclib_8h.html#a210dcd310e0c16c343f11c2e3c53984f" title="Set multiple configuration settings for a sensor. ">ch_set_config()</a></em> (or equivalent single-setting functions).</li>
</ol>
<p>At this point, the sensor will begin to perform measurements. At the end of each measurement cycle, the sensor will interrupt the host controller using its INT line. The handler routine set up in step #4 above will be called, and it should cause the application to read the measurement results from the sensor(s), using <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor. ">ch_get_range()</a></em> and optionally <em><a class="el" href="soniclib_8h.html#aa2ef517f154bb269d31fdf3f4e0cc7a2" title="Get the measured amplitude from a sensor. ">ch_get_amplitude()</a></em> and/or <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em>.</p>
<p>Do not trigger a new measurement until the previous measurement has completed and all needed data has been read from the device (including I/Q data, if <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em> is used). If any I/O operations are still active, the new measurement may be corrupted. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a28a351939686e7af66da8f2b70a9b709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a351939686e7af66da8f2b70a9b709">&#9670;&nbsp;</a></span>CH101_MAX_NUM_SAMPLES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH101_MAX_NUM_SAMPLES&#160;&#160;&#160;(150)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max expected samples per measurement for CH101. </p>

</div>
</div>
<a id="a93c47c2e19dd9fc3d57c60dac7961f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c47c2e19dd9fc3d57c60dac7961f89">&#9670;&nbsp;</a></span>CH101_PART_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH101_PART_NUMBER&#160;&#160;&#160;(101)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer sensor identifier for CH101. </p>

</div>
</div>
<a id="a26ab2faf29aed6b745da4ef07ca0f832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ab2faf29aed6b745da4ef07ca0f832">&#9670;&nbsp;</a></span>CH201_MAX_NUM_SAMPLES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH201_MAX_NUM_SAMPLES&#160;&#160;&#160;(450)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Max expected samples per measurement for CH201. </p>

</div>
</div>
<a id="a56d3738677a6b10d44580771ed7b8481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d3738677a6b10d44580771ed7b8481">&#9670;&nbsp;</a></span>CH201_PART_NUMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH201_PART_NUMBER&#160;&#160;&#160;(201)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer sensor identifier for CH201. </p>

</div>
</div>
<a id="a572265a83ea20b996e2b258388e36af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572265a83ea20b996e2b258388e36af2">&#9670;&nbsp;</a></span>CH_I2C_ADDR_PROG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_I2C_ADDR_PROG&#160;&#160;&#160;(0x45)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C address of sensor programming interface. </p>

</div>
</div>
<a id="a4f9925720bfd6eb5d7a25cd04f6ef512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f9925720bfd6eb5d7a25cd04f6ef512">&#9670;&nbsp;</a></span>CH_MIN_RANGE_VAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_MIN_RANGE_VAL&#160;&#160;&#160;(0x0001)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minimum range value returned for very short distances </p>

</div>
</div>
<a id="acb22435c0d7a9acf8898eefbaeb82791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb22435c0d7a9acf8898eefbaeb82791">&#9670;&nbsp;</a></span>CH_NO_TARGET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_NO_TARGET&#160;&#160;&#160;(0xFFFFFFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Range value returned if no target was detected. </p>

</div>
</div>
<a id="a564329279fbaa1d5d99bc15f30f229fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564329279fbaa1d5d99bc15f30f229fe">&#9670;&nbsp;</a></span>CH_NUM_THRESHOLDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_NUM_THRESHOLDS&#160;&#160;&#160;(6)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of internal detection thresholds (CH201 only). </p>

</div>
</div>
<a id="a4f7cfa228dcd15d047c080e173593211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7cfa228dcd15d047c080e173593211">&#9670;&nbsp;</a></span>CH_SIG_BYTE_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_SIG_BYTE_0&#160;&#160;&#160;(0x0a)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signature byte in sensor (1 of 2). </p>

</div>
</div>
<a id="ac4290230eebe5289b9f009a7a2963cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4290230eebe5289b9f009a7a2963cb6">&#9670;&nbsp;</a></span>CH_SIG_BYTE_1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_SIG_BYTE_1&#160;&#160;&#160;(0x02)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Signature byte in sensor (2 of 2). </p>

</div>
</div>
<a id="a9be1394366f99b9be3c1602bc0425b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be1394366f99b9be3c1602bc0425b67">&#9670;&nbsp;</a></span>CH_SPEEDOFSOUND_MPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CH_SPEEDOFSOUND_MPS&#160;&#160;&#160;(343)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Speed of sound, in meters per second. </p>

</div>
</div>
<a id="a4f072e4035752984408e51ca5118ed31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f072e4035752984408e51ca5118ed31">&#9670;&nbsp;</a></span>I2C_DRV_FLAG_RESET_AFTER_NB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_DRV_FLAG_RESET_AFTER_NB&#160;&#160;&#160;(0x00000001)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>I2C interface needs reset after non-blocking transfer. </p>

</div>
</div>
<a id="a8793cb8505c41937c8efa88d16696b37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8793cb8505c41937c8efa88d16696b37">&#9670;&nbsp;</a></span>I2C_DRV_FLAG_USE_PROG_NB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define I2C_DRV_FLAG_USE_PROG_NB&#160;&#160;&#160;(0x00000002)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use programming interface for non-blocking transfer. </p>

</div>
</div>
<a id="a3407caaf3d2f8bb12e8c26bccbe3ae40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3407caaf3d2f8bb12e8c26bccbe3ae40">&#9670;&nbsp;</a></span>SONICLIB_VER_MAJOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SONICLIB_VER_MAJOR&#160;&#160;&#160;(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SonicLib major version. </p>

</div>
</div>
<a id="a3114f821e7b6c5971ddf1c363597b761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3114f821e7b6c5971ddf1c363597b761">&#9670;&nbsp;</a></span>SONICLIB_VER_MINOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SONICLIB_VER_MINOR&#160;&#160;&#160;(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SonicLib minor version. </p>

</div>
</div>
<a id="a602271af8c1cf2ba218e68b49e5d465f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a602271af8c1cf2ba218e68b49e5d465f">&#9670;&nbsp;</a></span>SONICLIB_VER_REV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SONICLIB_VER_REV&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SonicLib revision. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a66b7f8516a2c66f0ccc72704f7d5d94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b7f8516a2c66f0ccc72704f7d5d94a">&#9670;&nbsp;</a></span>ch_io_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I/O blocking mode flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a66b7f8516a2c66f0ccc72704f7d5d94aa7a046d9f4e299da922c6f5e80bdbb4b8"></a>CH_IO_MODE_BLOCK&#160;</td><td class="fielddoc"><p>Blocking mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a66b7f8516a2c66f0ccc72704f7d5d94aa76c5fc9482109b8302837d621d58a833"></a>CH_IO_MODE_NONBLOCK&#160;</td><td class="fielddoc"><p>Non-blocking mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="a0da193cf2f2476d27fd7ceb533f8cdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da193cf2f2476d27fd7ceb533f8cdc4">&#9670;&nbsp;</a></span>ch_mode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sensor operating modes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0da193cf2f2476d27fd7ceb533f8cdc4ae0c08b8a3177f79eeb861205c7dac1f1"></a>CH_MODE_IDLE&#160;</td><td class="fielddoc"><p>Idle mode - low-power sleep, no sensing is enabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0da193cf2f2476d27fd7ceb533f8cdc4aaf3c359ba59ec257f215b09ad9d98248"></a>CH_MODE_FREERUN&#160;</td><td class="fielddoc"><p>Free-running mode - sensor uses internal clock to wake and measure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0da193cf2f2476d27fd7ceb533f8cdc4ab4ab53a6ca9bbf9c090e07b3e69d5c0e"></a>CH_MODE_TRIGGERED_TX_RX&#160;</td><td class="fielddoc"><p>Triggered transmit/receive mode - transmits and receives when INT line triggered. </p>
</td></tr>
<tr><td class="fieldname"><a id="a0da193cf2f2476d27fd7ceb533f8cdc4a78858c96eade25f0eee8dfcf7a629d01"></a>CH_MODE_TRIGGERED_RX_ONLY&#160;</td><td class="fielddoc"><p>Triggered receive-only mode - for pitch-catch operation with another sensor. </p>
</td></tr>
</table>

</div>
</div>
<a id="a1b137d77afad79d536e322eacdfebd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b137d77afad79d536e322eacdfebd0c">&#9670;&nbsp;</a></span>ch_range_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0c">ch_range_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range data types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b137d77afad79d536e322eacdfebd0cac6b9feacfe2dfe9809e4a1aeb5e98666"></a>CH_RANGE_ECHO_ONE_WAY&#160;</td><td class="fielddoc"><p>One way - gets full pulse/echo distance &amp; divides by 2. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b137d77afad79d536e322eacdfebd0ca3e14ab78ba174bd7883799b0fb5cbbcf"></a>CH_RANGE_ECHO_ROUND_TRIP&#160;</td><td class="fielddoc"><p>Round trip - full pulse/echo distance. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b137d77afad79d536e322eacdfebd0ca19a564606f15f72986b0912156cce533"></a>CH_RANGE_DIRECT&#160;</td><td class="fielddoc"><p>Direct - for receiving node in pitch-catch mode. </p>
</td></tr>
</table>

</div>
</div>
<a id="ada69fa98b2d110de6d1070c5150f8113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada69fa98b2d110de6d1070c5150f8113">&#9670;&nbsp;</a></span>ch_reset_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sensor reset types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ada69fa98b2d110de6d1070c5150f8113a7d47de24ba2696e1c1d5ad52b4ba2f84"></a>CH_RESET_HARD&#160;</td><td class="fielddoc"><p>Hard reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="ada69fa98b2d110de6d1070c5150f8113a148a4819dbb2953a7a78b14e24efe6c0"></a>CH_RESET_SOFT&#160;</td><td class="fielddoc"><p>Soft reset. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aa2ef517f154bb269d31fdf3f4e0cc7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ef517f154bb269d31fdf3f4e0cc7a2">&#9670;&nbsp;</a></span>ch_get_amplitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_amplitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measured amplitude from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amplitude value for most recent successful range reading</dd></dl>
<p>This function returns the amplitude value for the most recent successful range measurement by the sensor. The amplitude is representative of the incoming sound pressure. The value is expressed in internal sensor counts and is not calibrated to any standard units.</p>
<p>The amplitude value is not updated if a measurement cycle resulted in <em>CH_NO_TARGET</em>, as returned by <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor. ">ch_get_range()</a></em>. </p>

</div>
</div>
<a id="aecd6ee85a061f71da4e98aab683fef5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd6ee85a061f71da4e98aab683fef5b">&#9670;&nbsp;</a></span>ch_get_amplitude_avg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_amplitude_avg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the averaged measured amplitude over the sample window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Average amplitude value for samples in current sample window</dd></dl>
<p>This function returns the average amplitude value for the most recent measurement cycle across the samples within the current sample window. The sample window is a subset of the overall sensor data, and is specified by the <em><a class="el" href="soniclib_8h.html#a183c63e3d6794848986656895b918d10" title="Set the sample window for amplitude averaging. ">ch_set_sample_window()</a></em> function.</p>
<p>The amplitude is representative of the incoming sound pressure. The value is expressed in internal sensor counts and is not calibrated to any standard units.</p>
<dl class="section note"><dt>Note</dt><dd>Sample window averaging is only available when using special sensor firmware packages from Chirp. It is generally not available in General Purpose Rangefinding (GPR) firmware. </dd></dl>

</div>
</div>
<a id="af95998b37600ae7ef3a2300c10519fdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95998b37600ae7ef3a2300c10519fdf">&#9670;&nbsp;</a></span>ch_get_amplitude_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_amplitude_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the raw amplitude measurement data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">buf_ptr</td><td>pointer to data buffer where amplitude data will be written </td></tr>
    <tr><td class="paramname">start_sample</td><td>starting sample number within measurement data (0 = start of data) </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples to read from sensor </td></tr>
    <tr><td class="paramname">mode</td><td>whether read should block (<em>CH_IO_MODE_BLOCK</em> (0) = blocking, <em>CH_IO_MODE_NONBLOCK</em> (1) = non-blocking)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>The raw amplitude data are updated on every measurement cycle, even if no target was detected (i.e. even if <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor. ">ch_get_range()</a></em> returns <em>CH_NO_TARGET</em>). (Note that this is different than the regular amplitude value, as returned by <em><a class="el" href="soniclib_8h.html#aa2ef517f154bb269d31fdf3f4e0cc7a2" title="Get the measured amplitude from a sensor. ">ch_get_amplitude()</a></em>, which is <em>not</em> updated unless a target is detected.)</p>
<p>Each sample amplitude consists of one unsigned 16-bit integer value.</p>
<p>Amplitude values in the sensor are expressed only in internal ADC counts (least-significant bits, or LSBs) and are not calibrated to any standard units.</p>
<p>The number of samples available in each amplitude trace is determined by the maximum range setting for the device. If it is set to less than the maximum possible range, not all samples will contain valid data. To determine the number of active samples within the trace, use <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle. ">ch_get_num_samples()</a></em>. <br />
</p><ul>
<li>To read all valid amplitude data, set <em>start_sample</em> to zero (0), and set <em>num_samples</em> to the value returned by <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle. ">ch_get_num_samples()</a></em>.</li>
</ul>
<p>To determine what sample number corresponds to a physical distance, use <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor. ">ch_mm_to_samples()</a></em>.</p>
<p>To allow more flexibilty in your application, the amplitude data readout from the device may be done in a non-blocking mode, by setting <em>mode</em> to <em>CH_IO_MODE_NONBLOCK</em> (1). In non-blocking mode, the I/O operation takes place using DMA access in the background. This function will return immediately, and a notification will later be issued when the amplitude has been read. To use the <em>non_block</em> option, the board support package (BSP) you are using must provide the <em><a class="el" href="chirp__bsp_8h.html#a620cdc037bcd92bde953270a8cb15fc6" title="Read bytes from an I2C slave, non-blocking. ">chbsp_i2c_read_nb()</a></em> and <em>chbsp_i2c_read_mem_nb()</em> functions. To use non-blocking reads of the amplitude data, you must specify a callback routine that will be called when the amplitude read completes. See <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors. ">ch_io_complete_callback_set()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Non-blocking amplitude reads are only supported when using certain Chirp sensor firmware types which support direct readout of the amplitude data. Other firmware types read I/Q data and calculate the amplitudes as part of this function, and will require use of blocking mode (CH_IO_MODE_BLOCK). If non-blocking mode is specified when using sensor f/w that does not support it, this function will return an error.</dd></dl>
<p>Non-blocking reads are managed together for a group of sensors. To perform a non-blocking read:</p>
<ol type="1">
<li>Register a callback function using <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors. ">ch_io_complete_callback_set()</a></em>.</li>
<li>Define and initialize a handler for the DMA interrupts generated.</li>
<li>Synchronize with all sensors whose amplitude data should be read by waiting for all to indicate data ready.</li>
<li>Set up a non-blocking read on each sensor, using <em><a class="el" href="soniclib_8h.html#af95998b37600ae7ef3a2300c10519fdf" title="Get the raw amplitude measurement data from a sensor. ">ch_get_amplitude_data()</a></em> with <em>mode</em> = <em>CH_IO_MODE_NONBLOCK</em> (1).</li>
<li>Start the non-blocking reads on all sensors in the group, using <em><a class="el" href="soniclib_8h.html#af7b5f63c32c49bf634a00fc6594e57bc" title="Start non-blocking I/O operation(s) for a group of sensors. ">ch_io_start_nb()</a></em>.</li>
<li>Your callback function (set in step #1 above) will be called as each individual sensor's read completes. Your callback function should initiate any further processing of the I/Q data, possibly by setting a flag that will be checked from within the application's main execution loop. The callback function will likely be called at interrupt level, so the amount of processing within it should be kept to a minimum.</li>
</ol>
<p>For a CH101 sensor, up to 150 samples are taken during each measurement cycle; for a CH201 sensor, up to 450 samples are taken. So, a complete CH101 amplitude trace will contain up to 300 bytes of data (150 samples x 2 bytes per sample), and a CH201 amplitude trace may contain up to 900 bytes. The buffer specified by <em>buf_ptr</em> must be large enough to hold this amount of data.</p>
<p>When the amplitude data is read from the sensor, the additional time required to transfer the amplitude data over the I2C bus must be taken into account when planning how often the sensor can be read (sample interval). <br />
 </p><dl class="section note"><dt>Note</dt><dd>It is important that any data I/O operations to or from the sensor, including reading the amplitude data, complete before a new measurement cycle is triggered, or the new measurement may be affected.</dd>
<dd>
This function only obtains the data from the most recently completed measurement cycle. It does not actually trigger a measurement. </dd></dl>

</div>
</div>
<a id="a4d6216f922775cbf3c571734e5287d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d6216f922775cbf3c571734e5287d50">&#9670;&nbsp;</a></span>ch_get_bandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_bandwidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the bandwidth of a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the operating frequency of the sensor. This is the primary frequency of the ultrasonic pulse that is emitted by the device when transmitting. <br />
 </p><dl class="section return"><dt>Returns</dt><dd>Sensor bandwidth, in Hz, or 0 if error or bandwidth measurement is not available</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The bandwidth measurement is only available when using special sensor firmware packages from Chirp. It is generally not available in General Purpose Rangefinding (GPR) firmware. </dd></dl>

</div>
</div>
<a id="a2047b5e506b99131585bcfb4ce37b4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2047b5e506b99131585bcfb4ce37b4ac">&#9670;&nbsp;</a></span>ch_get_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__config__t.html">ch_config_t</a> *&#160;</td>
          <td class="paramname"><em>config_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get current configuration settings for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">config_ptr</td><td>pointer to a <a class="el" href="structch__config__t.html" title="Combined configuration structure. ">ch_config_t</a> structure to receive configuration values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function obtains the current configuration settings from the sensor and returns them in a <a class="el" href="structch__config__t.html" title="Combined configuration structure. ">ch_config_t</a> structure, whose address is specified by <em>config_ptr</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The individual configuration values returned in the <a class="el" href="structch__config__t.html" title="Combined configuration structure. ">ch_config_t</a> structure may also be obtained by using dedicated single-value functions. See <em><a class="el" href="soniclib_8h.html#acbd52987d0cfca5d0dec4f962ce15995" title="Get the current operating mode for a sensor. ">ch_get_mode()</a></em>, <em><a class="el" href="soniclib_8h.html#a96b6bb2df00b9feb43955902c55835f7" title="Get the maximum range setting for a sensor. ">ch_get_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#a973ae35d4ac7064704da5bcf2d05f6ef" title="Get the internal sample timing interval for a sensor. ">ch_get_sample_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#ad7b0b54393d6373c0f1c3db35d7f1cd8" title="Get static target rejection range setting. ">ch_get_static_range()</a></em>, and <em><a class="el" href="soniclib_8h.html#a9ea0971363f3a1c9fdc7e8f040489edd" title="Get detection thresholds (CH201 only). ">ch_get_thresholds()</a></em>. </dd></dl>

</div>
</div>
<a id="a775e8fcdd9f1c1fa3dd90d87024101ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a775e8fcdd9f1c1fa3dd90d87024101ab">&#9670;&nbsp;</a></span>ch_get_dev_num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_dev_num </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device number (I/O index values) for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Device number</dd></dl>
<p>This function returns the device number (I/O index) of the sensor within its sensor group. <br />
Normally, this also corresponds to the sensor's port number on the board, and is used for indexing arrays of pin definitions etc. within the board support package routines. </p>

</div>
</div>
<a id="a703c36ef2e38b7f9274c8e05a5109d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703c36ef2e38b7f9274c8e05a5109d72">&#9670;&nbsp;</a></span>ch_get_dev_ptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structch__dev__t.html">ch_dev_t</a>* ch_get_dev_ptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get device descriptor pointer for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> descriptor for this group of sensors </td></tr>
    <tr><td class="paramname">dev_num</td><td>device number within sensor group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</dd></dl>
<p>This function returns the address of the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> device descriptor for a certain sensor in a sensor group. The sensor is identified within the group by the <em>dev_num</em> device number. </p>

</div>
</div>
<a id="a7ae60d24c0b1d0fb5f06e2449c0fa149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae60d24c0b1d0fb5f06e2449c0fa149">&#9670;&nbsp;</a></span>ch_get_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_get_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the operating frequency of a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the operating frequency of the sensor. This is the primary frequency of the ultrasonic pulse that is emitted by the device when transmitting. <br />
 </p><dl class="section return"><dt>Returns</dt><dd>Frequency, in Hz </dd></dl>

</div>
</div>
<a id="ac4a2126fda5645c1be134c2187cac61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a2126fda5645c1be134c2187cac61f">&#9670;&nbsp;</a></span>ch_get_fw_version_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ch_get_fw_version_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the firmware version description string for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to character string describing sensor firmware version</dd></dl>
<p>This function returns a pointer to a string that describes the sensor firmware being used on the device. </p>

</div>
</div>
<a id="ab5496937b5fae4e2c04ff2fa23ed9fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5496937b5fae4e2c04ff2fa23ed9fbf">&#9670;&nbsp;</a></span>ch_get_i2c_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_i2c_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active I2C address for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C address, or 0 if error</dd></dl>
<p>This function returns the currently active I2C address for a sensor device. This function may be used by board support package routines to determine the proper I2C address to use for a specified sensor. </p>

</div>
</div>
<a id="a188023bdbeb0928f77a51a6ca5d254e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188023bdbeb0928f77a51a6ca5d254e9">&#9670;&nbsp;</a></span>ch_get_i2c_bus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_i2c_bus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the active I2C bus for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>I2C bus index</dd></dl>
<p>This function returns the I2C bus index for a sensor device. This function may be used by board support package routines to determine the proper I2C bus to use for a specified sensor. </p>

</div>
</div>
<a id="acde1c47209421107f576b7e01b6fa5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acde1c47209421107f576b7e01b6fa5e8">&#9670;&nbsp;</a></span>ch_get_iq_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_iq_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *&#160;</td>
          <td class="paramname"><em>buf_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a66b7f8516a2c66f0ccc72704f7d5d94a">ch_io_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the raw I/Q measurement data from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">buf_ptr</td><td>pointer to data buffer where I/Q data will be written </td></tr>
    <tr><td class="paramname">start_sample</td><td>starting sample number within measurement data (0 = start of data) </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples to read from sensor </td></tr>
    <tr><td class="paramname">mode</td><td>whether I/Q read should block (<em>CH_IO_MODE_BLOCK</em> (0) = blocking, <em>CH_IO_MODE_NONBLOCK</em> (1) = non-blocking)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function reads the raw I/Q measurement data from the sensor. The I/Q data set includes a discrete pair of values for each of the samples that make up a full measurement cycle. Each individual sample is reported as a pair of values, I and Q, in a quadrature format. The I/Q values may be used to calculate the relative amplitude of the measured ultrasound signal.</p>
<p>The contents of the I/Q trace are updated on every measurement cycle, even if no target was detected (i.e. even if <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor. ">ch_get_range()</a></em> returns <em>CH_NO_TARGET</em>). (Note that this is different than the regular amplitude value, as returned by <em><a class="el" href="soniclib_8h.html#aa2ef517f154bb269d31fdf3f4e0cc7a2" title="Get the measured amplitude from a sensor. ">ch_get_amplitude()</a></em>, which is <em>not</em> updated unless a target is detected.)</p>
<p>Each sample I/Q pair consists of two signed 16-bit integers and is described by the <em><a class="el" href="structch__iq__sample__t.html" title="Sensor I/Q data value. ">ch_iq_sample_t</a></em> structure. To convert any given pair of I/Q values to the amplitude value for that sample, square both I and Q, and take the square root of the sum: <br />
 </p><p class="formulaDsp">
\[Amp_n = \sqrt{(I_n)^2 + (Q_n)^2}\]
</p>
<p> Amplitude values in the sensor are expressed only in internal ADC counts (least-significant bits, or LSBs) and are not calibrated to any standard units.</p>
<p>The number of samples used in each I/Q trace is determined by the maximum range setting for the device. If it is set to less than the maximum possible range, not all samples will contain valid data. To determine the number of active samples within the trace, use <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle. ">ch_get_num_samples()</a></em>. <br />
</p><ul>
<li>To read all valid I/Q data, set <em>start_sample</em> to zero (0), and set <em>num_samples</em> to the value returned by <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle. ">ch_get_num_samples()</a></em>.</li>
</ul>
<p>To determine what sample number corresponds to a physical distance, use <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor. ">ch_mm_to_samples()</a></em>.</p>
<p>To allow more flexibilty in your application, the I/Q data readout from the device may be done in a non-blocking mode, by setting <em>mode</em> to <em>CH_IO_MODE_NONBLOCK</em> (1). In non-blocking mode, the I/O operation takes place using DMA access in the background. This function will return immediately, and a notification will later be issued when the I/Q has been read. To use the <em>non_block</em> option, the board support package (BSP) you are using must provide the <em><a class="el" href="chirp__bsp_8h.html#a620cdc037bcd92bde953270a8cb15fc6" title="Read bytes from an I2C slave, non-blocking. ">chbsp_i2c_read_nb()</a></em> and <em>chbsp_i2c_read_mem_nb()</em> functions. To use non-blocking reads of the I/Q data, you must specify a callback routine that will be called when the I/Q read completes. See <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors. ">ch_io_complete_callback_set()</a></em>.</p>
<p>Non-blocking reads are managed together for a group of sensors. To perform a non-blocking read:</p>
<ol type="1">
<li>Register a callback function using <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors. ">ch_io_complete_callback_set()</a></em>.</li>
<li>Define and initialize a handler for the DMA interrupts generated.</li>
<li>Synchronize with all sensors whose I/Q data should be read by waiting for all to indicate data ready.</li>
<li>Set up a non-blocking read on each sensor, using <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em> with <em>mode</em> = <em>CH_IO_MODE_NONBLOCK</em> (1).</li>
<li>Start the non-blocking reads on all sensors in the group, using <em><a class="el" href="soniclib_8h.html#af7b5f63c32c49bf634a00fc6594e57bc" title="Start non-blocking I/O operation(s) for a group of sensors. ">ch_io_start_nb()</a></em>.</li>
<li>Your callback function (set in step #1 above) will be called as each individual sensor's read completes. Your callback function should initiate any further processing of the I/Q data, possibly by setting a flag that will be checked from within the application's main execution loop. The callback function will likely be called at interrupt level, so the amount of processing within it should be kept to a minimum.</li>
</ol>
<p>For a CH101 sensor, up to 150 samples are taken during each measurement cycle; for a CH201 sensor, up to 450 samples are taken. So, a complete CH101 I/Q trace will contain up to 600 bytes of data (150 samples x 4 bytes per sample), and a CH201 I/Q trace may contain up to 1800 bytes. The buffer specified by <em>buf_ptr</em> must be large enough to hold this amount of data.</p>
<p>When the I/Q data is read from the sensor, the additional time required to transfer the I/Q data over the I2C bus must be taken into account when planning how often the sensor can be read (sample interval). <br />
 </p><dl class="section note"><dt>Note</dt><dd>It is important that any data I/O operations to or from the sensor, including reading the I/Q data, complete before a new measurement cycle is triggered, or the new measurement may be affected.</dd>
<dd>
This function only obtains the data from the most recently completed measurement cycle. It does not actually trigger a measurement. </dd></dl>

</div>
</div>
<a id="a96b6bb2df00b9feb43955902c55835f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b6bb2df00b9feb43955902c55835f7">&#9670;&nbsp;</a></span>ch_get_max_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_max_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum range setting for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum range setting, in millimeters</dd></dl>
<p>This function returns the current maximum detection range setting for the sensor, in millimeters.</p>
<dl class="section note"><dt>Note</dt><dd>The maximum range may also be obtained, along with other settings, using the <em><a class="el" href="soniclib_8h.html#a2047b5e506b99131585bcfb4ce37b4ac" title="Get current configuration settings for a sensor. ">ch_get_config()</a></em> function. </dd></dl>

</div>
</div>
<a id="a7eb50e63f45eee386a19cd9ef12c8de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb50e63f45eee386a19cd9ef12c8de6">&#9670;&nbsp;</a></span>ch_get_max_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_max_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the maximum possible sample count per measurement. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum sample count for this device and firmware</dd></dl>
<p>This function returns the maximum number of samples that can be included in a measurement. This maximum sample count will vary depending on the sensor device (CH201 devices will have higher sample counts than CH101 devices) and by the specific sensor firmware that is being used.</p>
<p>To get the number of these possible samples that are currently active (based on the maximum range setting), use <em><a class="el" href="soniclib_8h.html#a53cba94e769a33dfd290555efb412dda" title="Get the number of samples per measurement cycle. ">ch_get_num_samples()</a></em>. </p>

</div>
</div>
<a id="acbd52987d0cfca5d0dec4f962ce15995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd52987d0cfca5d0dec4f962ce15995">&#9670;&nbsp;</a></span>ch_get_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a> ch_get_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current operating mode for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> config structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sensor operating mode</dd></dl>
<p>This function returns the current operating mode for the sensor, one of:</p><ul>
<li><em>CH_MODE_IDLE</em> - low power idle mode, no measurements take place</li>
<li><em>CH_MODE_FREERUN</em> - free-running mode, sensor uses internal clock to wake and measure</li>
<li><em>CH_MODE_TRIGGERED_TX_RX</em> - hardware-triggered, sensor both transmits and receives</li>
<li><em>CH_MODE_TRIGGERED_RX_ONLY</em> - hardware triggered, sensor only receives </li>
</ul>

</div>
</div>
<a id="ae0a95de2412e067451248211003e1240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a95de2412e067451248211003e1240">&#9670;&nbsp;</a></span>ch_get_num_ports()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_num_ports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the total number of sensor ports (possible sensors) in a sensor group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> descriptor for this group of sensors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Total number of ports (possible sensors) in the sensor group</dd></dl>
<p>This function returns the maximum number of possible sensors within a sensor group. Typically, the number of sensors is limited by the physical connections on the board being used, so the number of sensor ports on the board is returned by this function. </p>

</div>
</div>
<a id="a53cba94e769a33dfd290555efb412dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53cba94e769a33dfd290555efb412dda">&#9670;&nbsp;</a></span>ch_get_num_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_num_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of samples per measurement cycle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of samples per measurement cycle</dd></dl>
<p>This function returns the current number of samples which the Chirp sensor will perform during each measurement cycle. The number of samples directly corresponds to the range at which the sensor can detect, so this value is determined by the current maximum range setting for the sensor. Also see <em><a class="el" href="soniclib_8h.html#a96b6bb2df00b9feb43955902c55835f7" title="Get the maximum range setting for a sensor. ">ch_get_max_range()</a></em>. </p>

</div>
</div>
<a id="ad57e731b7b145a37aa7685a2fbe320c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57e731b7b145a37aa7685a2fbe320c9">&#9670;&nbsp;</a></span>ch_get_part_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_part_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get part number for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer part number</dd></dl>
<p>This function returns the Chirp part number for the specified device. The part number is a simple integer value, for example 101 for a CH101 device. </p>

</div>
</div>
<a id="a5cbb4847d39cc9418373b6d1ac8dadc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbb4847d39cc9418373b6d1ac8dadc6">&#9670;&nbsp;</a></span>ch_get_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_get_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a1b137d77afad79d536e322eacdfebd0c">ch_range_t</a>&#160;</td>
          <td class="paramname"><em>range_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measured range from a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">range_type</td><td>the range type to be reported (e.g. one-way vs. round-trip)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Range in millimeters times 32, or <em>CH_NO_TARGET</em> (0xFFFFFFFF) if no target was detected, or 0 if error</dd></dl>
<p>This function reads the measurement result registers from the sensor and then computes the actual range. It should be called after the sensor has indicated that a measurement cycle is complete by generating a signal on the INT line. (Typically, this will be set up by an interrupt handler associated with that input line.)</p>
<p>The <em>range_type</em> parameter indicates whether the measurement is based on the one-way or round-trip distance to/from a target, or the direct distance between two sensors operating in pitch-catch mode. The possible values are:</p><ul>
<li><em>CH_RANGE_ECHO_ONE_WAY</em> - gets full pulse/echo round-trip distance, then divides by 2</li>
<li><em>CH_RANGE_ECHO_ROUND_TRIP</em> - full pulse/echo round-trip distance</li>
<li><em>CH_RANGE_DIRECT</em> - for receiving sensor in pitch-catch mode (one-way)</li>
</ul>
<p>This function returns the measured range as a 32-bit integer. For maximum precision, the range value is returned in a fixed-point format with 5 fractional bits. So, the return value is the number of millimeters times 32. Divide the value by 32 (shift right 5 bits) to get whole mm, or use floating point (i.e. divide by 32.0f) to preserve the full sub-millimeter precision.</p>
<p>If the sensor did not successfully find the range of a target during the most recent measurement, the returned range value will be <em>CH_NO_TARGET</em>. If an error occurs when getting or calculating the range, zero (0) will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>This function only reports the results from the most recently completed measurement cycle. It does not actually trigger a measurement.</dd>
<dd>
The <em>range_type</em> parameter only controls how this function interprets the results from the measurement cycle. It does not change the sensor mode. </dd></dl>

</div>
</div>
<a id="af1629cdf88732e9e3d4bfbe422900220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1629cdf88732e9e3d4bfbe422900220">&#9670;&nbsp;</a></span>ch_get_rtc_cal_pulselength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_rtc_cal_pulselength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real-time clock calibration pulse length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTC pulse length, in ms</dd></dl>
<p>This function returns the length (duration), in milliseconds, of the the real-time clock (RTC) calibration pulse used for the sensor. The pulse is applied to the sensor's INT line during <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors. ">ch_group_start()</a></em> to calibrate the sensor's internal clock. The pulse length is specified by the board support package during the <em><a class="el" href="chirp__bsp_8h.html#a1af911fb2af6031340dc1ffd93449a57" title="Main hardware initialization. ">chbsp_board_init()</a></em> function.</p>
<p>The RTC calibration pulse length is used internally in calculations that convert between time and distance. </p>

</div>
</div>
<a id="aa365c564c65b5aa97ca9dca28711807b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa365c564c65b5aa97ca9dca28711807b">&#9670;&nbsp;</a></span>ch_get_rtc_cal_result()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_rtc_cal_result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the real-time clock calibration value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>RTC calibration value</dd></dl>
<p>This function returns the real-time clock (RTC) calibration value read from the sensor during <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors. ">ch_group_start()</a></em>. The RTC calibration value is calculated by the sensor during the RTC calibration pulse, and it is used internally in calculations that convert between time and distance. </p>

</div>
</div>
<a id="ab71d5ac02276e0d9b77549eb29195d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab71d5ac02276e0d9b77549eb29195d6c">&#9670;&nbsp;</a></span>ch_get_rx_holdoff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_rx_holdoff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the receive holdoff sample count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of samples that are ignored at the beginning of each measurement</dd></dl>
<p>This function gets the receive (rx) holdoff sample count. The rx holdoff count is the number of samples at the beginning of a measurement that will be ignored for the purpose of detecting a target, as previously set by <em><a class="el" href="soniclib_8h.html#a4d2f18445966ba0094e54bfdae39bc0a" title="Set the receive holdoff sample count. ">ch_set_rx_holdoff()</a></em>.</p>
<p>To convert the returned sample count to a physical distance, use <em><a class="el" href="soniclib_8h.html#a290f3e5de2ee174e37ff4522df51d376" title="Convert sample count to millimeters for a sensor. ">ch_samples_to_mm()</a></em>. </p>

</div>
</div>
<a id="a0cb39266281e4aa908a2e57565a95696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb39266281e4aa908a2e57565a95696">&#9670;&nbsp;</a></span>ch_get_rx_pulse_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_rx_pulse_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the detected length of the received pulse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pulse length</dd></dl>
<p>This function gets the detected length of the received pulse</p>
<dl class="section note"><dt>Note</dt><dd>This config is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a973ae35d4ac7064704da5bcf2d05f6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973ae35d4ac7064704da5bcf2d05f6ef">&#9670;&nbsp;</a></span>ch_get_sample_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_sample_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the internal sample timing interval for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interval between samples (in ms), or 0 if device is not in free-running mode</dd></dl>
<p>This function returns the interval between measurements, in milliseconds, for for a sensor operating in free-running mode. If the sensor is in a different operating mode (e.g. a triggered mode), zero is returned. </p>

</div>
</div>
<a id="a56c552c6a09c2400766ee329efcaeaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c552c6a09c2400766ee329efcaeaa1">&#9670;&nbsp;</a></span>ch_get_sample_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_sample_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>start_sample_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>num_samples_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sample window for amplitude averaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">start_sample_ptr</td><td>pointer to variable to be updated with sample number of first sample </td></tr>
    <tr><td class="paramname">num_samples_ptr</td><td>pointer to variable to be updated with number of samples</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero if error</dd></dl>
<p>This function obtains the current range of samples that are included in the sample window used for amplitude averaging. <em>start_sample_ptr</em> is a pointer to a variable that will be updated with the number of the first sample in the sample window. <em>num_samples_ptr</em> is a pointer to a variable that will be updated with the the total number of samples in the sample window.</p>
<p>Also see <em><a class="el" href="soniclib_8h.html#aecd6ee85a061f71da4e98aab683fef5b" title="Get the averaged measured amplitude over the sample window. ">ch_get_amplitude_avg()</a></em> and <em><a class="el" href="soniclib_8h.html#a183c63e3d6794848986656895b918d10" title="Set the sample window for amplitude averaging. ">ch_set_sample_window()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Internal sample window averaging is available when using special sensor firmware packages from Chirp. In General Purpose Rangefinding (GPR) firmware, a software only implementation is used. </dd></dl>

</div>
</div>
<a id="ab88053b2f8918538fc3c2c8681e4269b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab88053b2f8918538fc3c2c8681e4269b">&#9670;&nbsp;</a></span>ch_get_scale_factor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_scale_factor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the calibration scale factor of a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function returns the calibration scale factor of the sensor. The scale factor is an internal value generated during the initialization of the device.</p>
<dl class="section return"><dt>Returns</dt><dd>Scale factor value, or 0 if error or not available</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The scale factor value is only available when using special sensor firmware packages from Chirp. It is generally not available in General Purpose Rangefinding (GPR) firmware. </dd></dl>

</div>
</div>
<a id="a7667d98222225444cc20a66649bbb36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7667d98222225444cc20a66649bbb36c">&#9670;&nbsp;</a></span>ch_get_static_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_static_coeff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the static coefficient for IIR filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>static coefficient</dd></dl>
<p>This function gets the static coefficient for IIR filter.</p>
<dl class="section note"><dt>Note</dt><dd>This config is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="ad7b0b54393d6373c0f1c3db35d7f1cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b0b54393d6373c0f1c3db35d7f1cd8">&#9670;&nbsp;</a></span>ch_get_static_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_static_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get static target rejection range setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Static target rejection range setting, in samples, or 0 if not enabled</dd></dl>
<p>This function returns the number of samples at the beginning of a measurement cycle over which static target rejection filtering will be applied. Also see <em><a class="el" href="soniclib_8h.html#ab7b5aecb6cfe54c6d2df428e26192d9a" title="Configure static target rejection. ">ch_set_static_range()</a></em>.</p>
<p>To calculate the physical distance that corresponds to the number of samples, use the <em><a class="el" href="soniclib_8h.html#a290f3e5de2ee174e37ff4522df51d376" title="Convert sample count to millimeters for a sensor. ">ch_samples_to_mm()</a></em> function. </p>

</div>
</div>
<a id="a5f37dcc63627f500f808fbe150fd9b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f37dcc63627f500f808fbe150fd9b89">&#9670;&nbsp;</a></span>ch_get_target_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_target_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the target detection interrupt mode setting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if target detection interrupt mode is enabled, 0 if disabled</dd></dl>
<p>This function returns the value of target detection interrupt mode setting.</p>
<dl class="section note"><dt>Note</dt><dd>Target detection interrupt mode is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a05448e0cd2c7bd018c6ca10d29aa5673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05448e0cd2c7bd018c6ca10d29aa5673">&#9670;&nbsp;</a></span>ch_get_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_get_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>threshold_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the detection threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">threshold_index</td><td>index to the thresholds, starts from 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>amplitude threshold value</dd></dl>
<p>This function obtains the detection threshold value of a given index from the sensor and returns it in amplitude .</p>
<dl class="section note"><dt>Note</dt><dd>This function is supported in CH201 and CH101 GPPC firmwares </dd></dl>

</div>
</div>
<a id="a9ea0971363f3a1c9fdc7e8f040489edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea0971363f3a1c9fdc7e8f040489edd">&#9670;&nbsp;</a></span>ch_get_thresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_thresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__thresholds__t.html">ch_thresholds_t</a> *&#160;</td>
          <td class="paramname"><em>thresh_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get detection thresholds (CH201 only). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">thresh_ptr</td><td>pointer to <a class="el" href="structch__thresholds__t.html" title="Multiple detection threshold structure (CH201 only). ">ch_thresholds_t</a> structure to receive threshold data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function obtains the current detection threshold values from the sensor and returns them in a <a class="el" href="structch__thresholds__t.html" title="Multiple detection threshold structure (CH201 only). ">ch_thresholds_t</a> structure specified by <em>thresh_ptr</em>. The <a class="el" href="structch__thresholds__t.html" title="Multiple detection threshold structure (CH201 only). ">ch_thresholds_t</a> structure holds an array of <a class="el" href="structch__thresh__t.html" title="Detection threshold value (CH201 only). ">ch_thresh_t</a> structures, each of which contains a starting sample number and amplitude threshold value. <br />
 </p><dl class="section note"><dt>Note</dt><dd>This function is not supported on CH101 devices. </dd></dl>

</div>
</div>
<a id="a38f2a32508f42eef57521790587023e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f2a32508f42eef57521790587023e6">&#9670;&nbsp;</a></span>ch_get_time_plan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="soniclib_8h.html#a23d84a030c9fc403cb538f5d0c3f3a52">ch_time_plan_t</a> ch_get_time_plan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read sonicsync timing plan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>a pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This routine returns the timing plan currently in use for an sonicsync master or slave node. The possible values are: SONICSYNC_TIME_PLAN_1 (0) SONICSYNC_TIME_PLAN_2 (1) SONICSYNC_TIME_PLAN_3 (2) SONICSYNC_TIME_PLAN_NONE (255)</p>
<p>For a master device, this value will always be the value specified in a previous call to ch101_sonicsync_set_time_plan(). If no such call was made, the master device will use the default time plan SONICSYNC_TIME_PLAN_1, and that value will be returned by this routine.</p>
<p>By default, a slave device initially uses SONICSYNC_TIME_PLAN_NONE, which causes the slave to cycle through the various time plans attempting to pair with the master. Until the slave has successfully paired with a master node, this routine will return SONICSYNC_TIME_PLAN_NONE.</p>
<p>Once the slave has successfully discovered and paired with a master, this routine will return the value indicating the time plan. Therefore, this routine may be used a polling mechanism to determine when a slave has successfully paired. Once paired, the time plan value for the slave will not change (unless explicitly set using the ch101_sonicsync_set_time_plan() routine).</p>
<dl class="section return"><dt>Returns</dt><dd>time plan value currently in use </dd></dl>

</div>
</div>
<a id="a3c05a1edba09919240c5d3db8f5a882b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c05a1edba09919240c5d3db8f5a882b">&#9670;&nbsp;</a></span>ch_get_tof_tick()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ch_get_tof_tick </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timer_freq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the measured Time-of-flight from a sensor in the ultrasound periodic timer tick. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">timer_freq</td><td>the HW frequency of the ultrasound periodic timer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Time-of-flight in tick, or 0 if error</dd></dl>
<p>This function reads the measurement result registers from the sensor and then computes the timer tick by the given HW frequency of the ultrasound periodic timer. <br />
</p>
<p>This function returns the measured timer tick as a 32-bit integer.</p>
<p>If the sensor did not successfully find the range of a target during the most recent measurement, the returned timer tick value will be <em>zero</em> (0). If an error occurs when getting or calculating the range, zero (0) will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>This function only reports the results from the most recently completed measurement cycle. It does not actually trigger a measurement. </dd></dl>

</div>
</div>
<a id="a1da9e8a079f9df8b2e250461bddb3b76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da9e8a079f9df8b2e250461bddb3b76">&#9670;&nbsp;</a></span>ch_get_tx_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_get_tx_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the TX length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TX length</dd></dl>
<p>This function gets the TX length</p>
<dl class="section note"><dt>Note</dt><dd>This config is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a63c386c49a6c8ad4bb506c4d00e3bcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c386c49a6c8ad4bb506c4d00e3bcf5">&#9670;&nbsp;</a></span>ch_group_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_group_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a>&#160;</td>
          <td class="paramname"><em>reset_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> descriptor for this group of sensors </td></tr>
    <tr><td class="paramname">reset_type</td><td>type of reset (<em>CH_RESET_HARD</em> or <em>CH_RESET_SOFT</em>)</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets all sensors in a sensor group. The <em>reset_type</em> parameter indicates if a software reset or full hardware reset is requested. </p>

</div>
</div>
<a id="a3d1acc5372d38d7abd7028a5504e5634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1acc5372d38d7abd7028a5504e5634">&#9670;&nbsp;</a></span>ch_group_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_group_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Program and start a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> descriptor for sensor group to be started</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function performs the actual discovery, programming, and initialization sequence for all sensors within a sensor group. Each sensor must have previously been added to the group by calling <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor. ">ch_init()</a></em>.</p>
<p>In brief, this function does the following for each sensor:</p><ul>
<li>Probe the possible sensor ports using I2C bus and each sensor's PROG line, to discover if sensor is connected.</li>
<li>Reset sensor.</li>
<li>Program sensor with firmware (version specified during <em><a class="el" href="soniclib_8h.html#afb33f776f4a2d55c885023798402c2a5" title="Initialize the device descriptor for a sensor. ">ch_init()</a></em>).</li>
<li>Assign unique I2C address to sensor (specified by board support package, see <em><a class="el" href="chirp__bsp_8h.html#a260d9c119fdb1db98ecaba6da5365576" title="Return I2C information for a sensor port on the board. ">chbsp_i2c_get_info()</a></em>).</li>
<li>Start sensor execution.</li>
<li>Wait for sensor to lock (complete initialization, including self-test).</li>
<li>Send timed pulse on INT line to calibrate sensor Real-Time Clock (RTC).</li>
</ul>
<p>After this routine returns successfully, the sensor configuration may be set and ultrasonic measurements may begin. </p>

</div>
</div>
<a id="aa4e917eea19df611680dc97e2401db3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e917eea19df611680dc97e2401db3a">&#9670;&nbsp;</a></span>ch_group_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_group_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a measurement on a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> descriptor for this group of sensors</td></tr>
  </table>
  </dd>
</dl>
<p>This function generates a pulse on the INT line for each sensor in the sensor group. If a sensor is in either <em>CH_MODE_TRIGGERED_TX_RX</em> or <em>CH_MODE_TRIGGERED_RX_ONLY</em> mode, this pulse will begin a measurement cycle.</p>
<p>If a two or more sensors are operating in pitch-catch mode (in which one transmits and the others receive), this function must be used to start a measurement cycle, so that the devices are synchronized.</p>
<p>To trigger a single sensor, use <em><a class="el" href="soniclib_8h.html#ade5083e622e8cc3852a4193f6d8dce9c" title="Trigger a measurement on one sensor. ">ch_trigger()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Do not trigger a new measurement until the previous measurement has completed and all needed data has been read from the device (including I/Q data, if <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em> is used). If any I/O operations are still active, the new measurement may be corrupted. </dd></dl>

</div>
</div>
<a id="afb33f776f4a2d55c885023798402c2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb33f776f4a2d55c885023798402c2a5">&#9670;&nbsp;</a></span>ch_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>dev_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a4e9d2049253328d1a1c57458a70d29e9">ch_fw_init_func_t</a>&#160;</td>
          <td class="paramname"><em>fw_init_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the device descriptor for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> descriptor for sensor group to join </td></tr>
    <tr><td class="paramname">dev_num</td><td>number of the device within the sensor group (identifies which physical sensor) </td></tr>
    <tr><td class="paramname">fw_init_func</td><td>pointer to the sensor firmware initialization function (determines sensor feature set)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function is used to initialize various Chirp SonicLib structures before using a sensor. The <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> device descriptor is the primary data structure used to manage a sensor, and its address will subsequently be used as a handle to identify the sensor when calling most API functions.</p>
<p>The <em>dev_ptr</em> parameter is the address of the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure that will be initialized and then used to identify and manage this sensor. The <em>grp_ptr</em> parameter is the address of a <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> structure describing the sensor group that will include the new sensor. Both the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> structure and the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> structure must have already been allocated before this function is called.</p>
<p>Generally, an application will require only one <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> structure to manage all Chirp sensors. However, a separate <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> structure must be allocated for each sensor.</p>
<p><em>dev_num</em> is a simple index value that uniquely identifies a sensor within a group. Each possible sensor (i.e. each physical port on the board that could have a Chirp sensor attached) has a number, starting with zero (0). The device number is constant - it remains associated with a specific port even if no sensor is actually attached. Often, the <em>dev_num</em> value is used by both the application and the board support package as an index into arrays containing per-sensor information (e.g. data read from the sensors, pin assignments, etc.).</p>
<p>The Chirp sensor is fully re-programmable, and the specific features and capabilities can be modified by using different sensor firmware images. The <em>fw_init_func</em> parameter is the address (name) of the sensor firmware initialization routine that should be used to program the sensor and prepare it for operation. The selection of this routine name is the only required change when switching from one sensor firmware image to another.</p>
<dl class="section note"><dt>Note</dt><dd>This function only performs internal initialization of data structures, etc. It does not actually initialize the physical sensor device(s). See <em><a class="el" href="soniclib_8h.html#a3d1acc5372d38d7abd7028a5504e5634" title="Program and start a group of sensors. ">ch_group_start()</a></em>. </dd></dl>

</div>
</div>
<a id="ae40302a26ef7dd9868f5c28bcfc15cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40302a26ef7dd9868f5c28bcfc15cea">&#9670;&nbsp;</a></span>ch_io_complete_callback_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_io_complete_callback_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a98e3bc51c237abf8b03ce396db3f7caf">ch_io_complete_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback_func_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register non-blocking I/O complete callback routine for a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> group descriptor structure </td></tr>
    <tr><td class="paramname">callback_func_ptr</td><td>pointer to callback function to be called when non-blocking I/O operations complete</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the routine specified by <em>callback_func_ptr</em> to be called when all outstanding non-blocking I/O operations complete for a group of sensors. The non-blocking I/O operations must have previously been initiated using <em><a class="el" href="soniclib_8h.html#af7b5f63c32c49bf634a00fc6594e57bc" title="Start non-blocking I/O operation(s) for a group of sensors. ">ch_io_start_nb()</a></em>. </p>

</div>
</div>
<a id="af3d4045f3510d82596c8231123e890b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d4045f3510d82596c8231123e890b9">&#9670;&nbsp;</a></span>ch_io_int_callback_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_io_int_callback_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a58c068c499b8a0c1069751041444da20">ch_io_int_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback_func_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register sensor interrupt callback routine for a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> sensor group descriptor structure </td></tr>
    <tr><td class="paramname">callback_func_ptr</td><td>pointer to callback function to be called when sensor interrupts</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers the routine specified by <em>callback_func_ptr</em> to be called whenever the sensor interrupts. Generally, such an interrupt indicates that a measurement cycle has completed and the sensor has data ready to be read. All sensors in a sensor group use the same callback function, which receives the interrupting device's device number (port number) as an input parameter to identify the specific interrupting device. </p>

</div>
</div>
<a id="a32b5931001ef934347a12daa46d700a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b5931001ef934347a12daa46d700a7">&#9670;&nbsp;</a></span>ch_io_notify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_io_notify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2c_bus_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify SonicLib that a non-blocking I/O operation has completed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> sensor group descriptor structure </td></tr>
    <tr><td class="paramname">i2c_bus_index</td><td>identifier indicating on which I2C bus the I/O operation was completed</td></tr>
  </table>
  </dd>
</dl>
<p>This function should be called from your non-blocking I/O interrupt handler each time a non-blocking I/O operation completes. The <em>i2c_bus_index</em> parameter should indicate which I2C bus is being reported.</p>
<p>When all outstanding non-blocking I/O operations are complete, SonicLib will call the callback function previously registered using <em><a class="el" href="soniclib_8h.html#ae40302a26ef7dd9868f5c28bcfc15cea" title="Register non-blocking I/O complete callback routine for a group of sensors. ">ch_io_complete_callback_set()</a></em>. </p>

</div>
</div>
<a id="af7b5f63c32c49bf634a00fc6594e57bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b5f63c32c49bf634a00fc6594e57bc">&#9670;&nbsp;</a></span>ch_io_start_nb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_io_start_nb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start non-blocking I/O operation(s) for a group of sensors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> descriptor for sensor group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function starts one or more non-blocking I/O operations on a group of sensors. <br />
Generally, the I/O operations are non-blocking I/Q data read requests individually generated using <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em>.</p>
<p>This function will return immediately after the I/O operations are started. When the I/O operations complete, the callback function registered using <em>ch_io_callback_set()</em> will be called.</p>
<p>See <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em> for more information. </p>

</div>
</div>
<a id="a21c53aa278150f204d7dd4eaef3cbb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c53aa278150f204d7dd4eaef3cbb95">&#9670;&nbsp;</a></span>ch_iq_to_amplitude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_iq_to_amplitude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__iq__sample__t.html">ch_iq_sample_t</a> *&#160;</td>
          <td class="paramname"><em>iq_sample_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate amplitude from sample I/Q values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iq_sample_ptr</td><td>pointer to ch_iq_data_t structure containing the I/Q data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Amplitude value</dd></dl>
<p>This function converts the I and Q values from a single raw sensor sample to an amplitude value according to the following formula: </p><p class="formulaDsp">
\[Amp = \sqrt{(I)^2 + (Q)^2}\]
</p>
<p>Amplitude values in the sensor are expressed only in internal ADC counts (least-significant bits, or LSBs) and are not calibrated to any standard units.</p>
<p>Also see <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em> and <em><a class="el" href="soniclib_8h.html#af95998b37600ae7ef3a2300c10519fdf" title="Get the raw amplitude measurement data from a sensor. ">ch_get_amplitude_data()</a></em>. </p>

</div>
</div>
<a id="aa256c720961a6d327c515da60d8071c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa256c720961a6d327c515da60d8071c2">&#9670;&nbsp;</a></span>ch_mm_to_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_mm_to_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_mm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert millimeters to sample count for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_mm</td><td>number of millimeters to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of samples</dd></dl>
<p>This function converts the distance in millimeters specified in <em>num_mm</em> and converts it to the corresponding number of sensor samples. The conversion uses values set during device initialization and calibration that describe the internal timing of the sensor, along with the current maximum range setting for the device.</p>
<p>This function may be helpful when working with both physical distances (as reported by the <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor. ">ch_get_range()</a></em> function) and sample-oriented values, such as data obtained from <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em> or parameters for static target rejection (see <em><a class="el" href="soniclib_8h.html#ab7b5aecb6cfe54c6d2df428e26192d9a" title="Configure static target rejection. ">ch_set_static_range()</a></em>). </p>

</div>
</div>
<a id="a38861d5f023ea837a9ee15bdca5fa114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38861d5f023ea837a9ee15bdca5fa114">&#9670;&nbsp;</a></span>ch_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#ada69fa98b2d110de6d1070c5150f8113">ch_reset_t</a>&#160;</td>
          <td class="paramname"><em>reset_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">reset_type</td><td>type of reset (<em>CH_RESET_HARD</em> or <em>CH_RESET_SOFT</em>)</td></tr>
  </table>
  </dd>
</dl>
<p>This function resets a sensor. The <em>reset_type</em> parameter indicates if a software reset or full hardware reset is requested. </p>

</div>
</div>
<a id="a290f3e5de2ee174e37ff4522df51d376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290f3e5de2ee174e37ff4522df51d376">&#9670;&nbsp;</a></span>ch_samples_to_mm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ch_samples_to_mm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert sample count to millimeters for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_samples</td><td>sample count to be converted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of millimeters</dd></dl>
<p>This function converts the sample count specified in <em>num_samples</em> and converts it to the corresponding physical distance in millimeters. The conversion uses values set during device initialization and calibration that describe the internal timing of the sensor.</p>
<p>This function may be helpful when working with both physical distances (as reported by the <em><a class="el" href="soniclib_8h.html#a5cbb4847d39cc9418373b6d1ac8dadc6" title="Get the measured range from a sensor. ">ch_get_range()</a></em> function) and sample-oriented values, such as data obtained from <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em> or parameters for static target rejection (see <em><a class="el" href="soniclib_8h.html#ab7b5aecb6cfe54c6d2df428e26192d9a" title="Configure static target rejection. ">ch_set_static_range()</a></em>). </p>

</div>
</div>
<a id="a1ea97825e46bd60eeb79cd5a155f80d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ea97825e46bd60eeb79cd5a155f80d0">&#9670;&nbsp;</a></span>ch_sensor_is_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_sensor_is_connected </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicate if a sensor is connected. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the sensor is connected, 0 otherwise </dd></dl>

</div>
</div>
<a id="a210dcd310e0c16c343f11c2e3c53984f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210dcd310e0c16c343f11c2e3c53984f">&#9670;&nbsp;</a></span>ch_set_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__config__t.html">ch_config_t</a> *&#160;</td>
          <td class="paramname"><em>config_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set multiple configuration settings for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">config_ptr</td><td>pointer to a <a class="el" href="structch__config__t.html" title="Combined configuration structure. ">ch_config_t</a> structure containing new configuration values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if error</dd></dl>
<p>This function sets multiple configuration options within the sensor. The configuration settings are passed in a <a class="el" href="structch__config__t.html" title="Combined configuration structure. ">ch_config_t</a> structure, whose address is specified by <em>config_ptr</em>. The fields in the <a class="el" href="structch__config__t.html" title="Combined configuration structure. ">ch_config_t</a> structure must have been set with your new configuration values before this function is called.</p>
<dl class="section note"><dt>Note</dt><dd>The individual configuration values set by this function may also be set using dedicated single-value functions. These two methods are completely equivalent and may be freely mixed. <br />
See <em><a class="el" href="soniclib_8h.html#af427c34df885a028ee0f7cdddc981001" title="Configure a sensor for the specified operating mode. ">ch_set_mode()</a></em>, <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor. ">ch_set_max_range()</a></em>, <em><a class="el" href="soniclib_8h.html#ae3a08fc3bf063f817bb28cd666d19fa2" title="Configure the internal sample interval for a sensor in freerunning mode. ">ch_set_sample_interval()</a></em>, <em><a class="el" href="soniclib_8h.html#ab7b5aecb6cfe54c6d2df428e26192d9a" title="Configure static target rejection. ">ch_set_static_range()</a></em>, and <em><a class="el" href="soniclib_8h.html#a7e948bfbdc2cbca2f04bc97459541e5f" title="Set detection thresholds (CH201 only). ">ch_set_thresholds()</a></em>. </dd></dl>

</div>
</div>
<a id="a3ff28a47fdf01cc9f893b85a900db145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff28a47fdf01cc9f893b85a900db145">&#9670;&nbsp;</a></span>ch_set_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_frequency </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>target_freq_Hz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the operating frequency of a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">target_freq_Hz</td><td>to the target frequency in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function set the target operating frequency of the sensor. This is the primary frequency of the ultrasonic pulse that is emitted by the device when transmitting. </p>

</div>
</div>
<a id="a41a264ebc25b13778176e83c0c910997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a264ebc25b13778176e83c0c910997">&#9670;&nbsp;</a></span>ch_set_max_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_max_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the maximum range for a sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">max_range</td><td>maximum range, in millimeters</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero if error</dd></dl>
<p>This function sets the maximum detection range for the sensor, in millimeters. The detection range setting controls how long the sensor will listen (i.e. how many samples it will capture) during each measurement cycle. (The number of samples is automatically calculated for the specified range.)</p>
<dl class="section note"><dt>Note</dt><dd>The maximum range may also be specified, along with other settings, using the <em><a class="el" href="soniclib_8h.html#a210dcd310e0c16c343f11c2e3c53984f" title="Set multiple configuration settings for a sensor. ">ch_set_config()</a></em> function. These two methods are completely equivalent and may be freely mixed. </dd></dl>

</div>
</div>
<a id="af427c34df885a028ee0f7cdddc981001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af427c34df885a028ee0f7cdddc981001">&#9670;&nbsp;</a></span>ch_set_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a0da193cf2f2476d27fd7ceb533f8cdc4">ch_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure a sensor for the specified operating mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">mode</td><td>the new operating mode for the sensor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful.</dd></dl>
<p>This function sets the sensor to operate in the specified mode, which must be one of the following:</p><ul>
<li><em>CH_MODE_IDLE</em> - low power idle mode, no measurements take place</li>
<li><em>CH_MODE_FREERUN</em> - free-running mode, sensor uses internal clock to wake and measure</li>
<li><em>CH_MODE_TRIGGERED_TX_RX</em> - hardware-triggered, sensor both transmits and receives</li>
<li><em>CH_MODE_TRIGGERED_RX_ONLY</em> - hardware triggered, sensor only receives </li>
</ul>

</div>
</div>
<a id="a8a92fdea71bf1aff4b05891a933a5e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a92fdea71bf1aff4b05891a933a5e84">&#9670;&nbsp;</a></span>ch_set_num_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_num_samples </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sensor sample count directly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor struct </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples during each measurement cycle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful</dd></dl>
<p>This function directly sets the number of samples which the Chirp sensor will perform during a single measurement cycle. The number of samples directly corresponds to the range at which the sensor can detect.</p>
<p>Also see <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor. ">ch_set_max_range()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Normally, the sample is count is not set using this function, but is instead set indirectly using either <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor. ">ch_set_max_range()</a></em> or <em><a class="el" href="soniclib_8h.html#a210dcd310e0c16c343f11c2e3c53984f" title="Set multiple configuration settings for a sensor. ">ch_set_config()</a></em>, both of which automatically set the sample count based on a specified range in millimeters. </dd></dl>

</div>
</div>
<a id="a4d2f18445966ba0094e54bfdae39bc0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2f18445966ba0094e54bfdae39bc0a">&#9670;&nbsp;</a></span>ch_set_rx_holdoff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_rx_holdoff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the receive holdoff sample count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_samples</td><td>the number of samples to be ignored at the beginning of each measurement</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the receive (rx) holdoff sample count. <em>num_samples</em> specifies a number of samples at the beginning of a measurement that will be ignored for the purpose of detecting a target. To convert a physical distance into a sample count value to use here, use <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor. ">ch_mm_to_samples()</a></em>.</p>
<p>See also <em><a class="el" href="soniclib_8h.html#ab71d5ac02276e0d9b77549eb29195d6c" title="Get the receive holdoff sample count. ">ch_get_rx_holdoff()</a></em>. </p>

</div>
</div>
<a id="aee0bbd8d9e2d5e1064fa8eb9ace180f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0bbd8d9e2d5e1064fa8eb9ace180f7">&#9670;&nbsp;</a></span>ch_set_rx_pretrigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_set_rx_pretrigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__group__t.html">ch_group_t</a> *&#160;</td>
          <td class="paramname"><em>grp_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable receive-only sensor pre-triggering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grp_ptr</td><td>pointer to the <a class="el" href="structch__group__t.html" title="Chirp sensor group configuration structure. ">ch_group_t</a> group descriptor structure </td></tr>
    <tr><td class="paramname">enable</td><td>1 to enable pre-triggering, 0 to disable</td></tr>
  </table>
  </dd>
</dl>
<p>This function enables or disables pre-triggering of the receive-only sensor during Pitch-Catch operation. When pre-triggering is enabled, sensors in CH_MODE_TRIGGERED_RX_ONLY mode will be triggered slightly before sensors in CH_MODE_TRIGGERED_TX_RX mode when <em><a class="el" href="soniclib_8h.html#aa4e917eea19df611680dc97e2401db3a" title="Trigger a measurement on a group of sensors. ">ch_group_trigger()</a></em> is called. This improves the ability of the receive-only sensor to detect the transmitted pulse at very short distances.</p>
<p>If enabled, pre-triggering is used for all receive-only sensors in the sensor group.</p>
<p>To use this function, set <em>enable</em> to 1 to enable pre-triggering, or 0 to disable pre-triggering.</p>
<dl class="section note"><dt>Note</dt><dd>Enabling pre-triggering will reduce the maximum range of the receive-only sensor(s), relative to the setting specified in <em><a class="el" href="soniclib_8h.html#a41a264ebc25b13778176e83c0c910997" title="Set the maximum range for a sensor. ">ch_set_max_range()</a></em>, by about 200mm. You may want to increase the maximum range setting accordingly. </dd></dl>

</div>
</div>
<a id="ae3a08fc3bf063f817bb28cd666d19fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a08fc3bf063f817bb28cd666d19fa2">&#9670;&nbsp;</a></span>ch_set_sample_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_sample_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>interval_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the internal sample interval for a sensor in freerunning mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">interval_ms</td><td>interval between samples, in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, 1 if arguments are invalid.</dd></dl>
<p>This function sets the sample interval for a sensor operating in freerunning mode (<em>CH_MODE_FREERUN</em>). The sensor will use its internal clock to wake and perform a measurement every <em>interval_ms</em> milliseconds.</p>
<dl class="section note"><dt>Note</dt><dd>This function has no effect for a sensor operating in one of the triggered modes. The sample interval for a triggered device is determined by the external trigger timing. </dd></dl>

</div>
</div>
<a id="a183c63e3d6794848986656895b918d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183c63e3d6794848986656895b918d10">&#9670;&nbsp;</a></span>ch_set_sample_window()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_sample_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>start_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sample window for amplitude averaging. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">start_sample</td><td>sample number of first sample in window </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of samples to include in window</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero if error</dd></dl>
<p>This function sets the sample range to be included in the sample window used for amplitude averaging. <em>start_sample</em> is the number of the first sample that will be included in the averaging window. <em>num_samples</em> is the total number of samples that will be included. <br />
 Also see <em><a class="el" href="soniclib_8h.html#aecd6ee85a061f71da4e98aab683fef5b" title="Get the averaged measured amplitude over the sample window. ">ch_get_amplitude_avg()</a></em> and <em><a class="el" href="soniclib_8h.html#a56c552c6a09c2400766ee329efcaeaa1" title="Get the sample window for amplitude averaging. ">ch_get_sample_window()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Internal sample window averaging is available when using special sensor firmware packages from Chirp. In General Purpose Rangefinding (GPR) firmware, a software only implementation is used. </dd></dl>

</div>
</div>
<a id="a872db7bc23cd2a4d2f1abe5e7551a484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872db7bc23cd2a4d2f1abe5e7551a484">&#9670;&nbsp;</a></span>ch_set_static_coeff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_static_coeff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>static_coeff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the static coefficient for IIR filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">static_coeff</td><td>the static coefficient for IIR filter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the static coefficient for IIR filter</p>
<p>If TX length are set lower, you may decrease the static coefficient.</p>
<p>If TX length are set higher, you may increase the static coefficient.</p>
<dl class="section note"><dt>Note</dt><dd>This config is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="ab7b5aecb6cfe54c6d2df428e26192d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7b5aecb6cfe54c6d2df428e26192d9a">&#9670;&nbsp;</a></span>ch_set_static_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_static_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure static target rejection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">num_samples</td><td>number of sensor samples (at beginning of measurement cycle) over which static targets will be rejected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if successful, non-zero if error</dd></dl>
<p>Static target rejection is a special processing mode in which the sensor will actively filter out signals from close, non-moving objects, so that they do not continue to generate range readings. This allows detection and reporting of target objects that are farther away than the static objects. (Normally, the sensor reports the range value for the closest detected object.)</p>
<p>Static target rejection is applied for a specified number of samples, starting at the beginning of a measurement cycle* (i.e. for the closest objects). The num_samples parameter specifies the number of samples that will be filtered. To calculate the appropriate value for <em>num_samples</em> to filter over a certain physical distance, use the <em><a class="el" href="soniclib_8h.html#aa256c720961a6d327c515da60d8071c2" title="Convert millimeters to sample count for a sensor. ">ch_mm_to_samples()</a></em> function. </p>

</div>
</div>
<a id="a5b75d1339613e2f899d1b3b19933d245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b75d1339613e2f899d1b3b19933d245">&#9670;&nbsp;</a></span>ch_set_target_interrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_target_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set target detection interrupt mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">enable</td><td>enable or disable target interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function enables or disables the target detection interrupt mode.</p>
<p>In normal operation (if target detection interrupt mode is not enabled), the sensor will assert the INT line at the end of a measurement whether or not a target was detected.</p>
<p>When target detection interrupt mode is enabled, the sensor will only assert the INT line at the end of a measurement if a target object was detected. If no target is detected, the sensor will not assert the INT line. There is no indication from the sensor that the measurement has completed.</p>
<p>To use this function, set <em>enable</em> to 1 to enable target detection interrupt mode. Set <em>enable</em> to 0 to disable the target detection interrupt mode.</p>
<dl class="section note"><dt>Note</dt><dd>Target detection interrupt mode is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="a221935be365b6c9fa5b2711c7df57750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221935be365b6c9fa5b2711c7df57750">&#9670;&nbsp;</a></span>ch_set_threshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_threshold </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>threshold_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>amplitude</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the detection threshold. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">threshold_index</td><td>index to the thresholds, starts from 0 </td></tr>
    <tr><td class="paramname">amplitude</td><td>amplitude threshold value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function set the detection threshold value of a given index to the sensor.</p>
<dl class="section note"><dt>Note</dt><dd>This function is supported in CH201 and CH101 GPPC firmwares. </dd></dl>

</div>
</div>
<a id="a7e948bfbdc2cbca2f04bc97459541e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e948bfbdc2cbca2f04bc97459541e5f">&#9670;&nbsp;</a></span>ch_set_thresholds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_thresholds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structch__thresholds__t.html">ch_thresholds_t</a> *&#160;</td>
          <td class="paramname"><em>thresh_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set detection thresholds (CH201 only). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">thresh_ptr</td><td>pointer to <a class="el" href="structch__thresholds__t.html" title="Multiple detection threshold structure (CH201 only). ">ch_thresholds_t</a> structure containing threshold data</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function obtains the current detection threshold values from the sensor and returns them in a <a class="el" href="structch__thresholds__t.html" title="Multiple detection threshold structure (CH201 only). ">ch_thresholds_t</a> structure specified by <em>thresh_ptr</em>. The <a class="el" href="structch__thresholds__t.html" title="Multiple detection threshold structure (CH201 only). ">ch_thresholds_t</a> structure holds an array of <a class="el" href="structch__thresh__t.html" title="Detection threshold value (CH201 only). ">ch_thresh_t</a> structures, each of which contains a starting sample number and amplitude threshold value.</p>
<p>To use this function, first initialize the <a class="el" href="structch__thresh__t.html" title="Detection threshold value (CH201 only). ">ch_thresh_t</a> sample/level pair of values for each threshold. A CH201 device supports six (6) thresholds. Each threshold has a maximum sample length of 255.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not supported on CH101 devices. </dd></dl>

</div>
</div>
<a id="a521bfb331d13a9fa2cdfecf909038c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521bfb331d13a9fa2cdfecf909038c92">&#9670;&nbsp;</a></span>ch_set_time_plan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_time_plan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="soniclib_8h.html#a23d84a030c9fc403cb538f5d0c3f3a52">ch_time_plan_t</a>&#160;</td>
          <td class="paramname"><em>time_plan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure sonicsync timing plan. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>a pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">time_plan</td><td>time plan identifier</td></tr>
  </table>
  </dd>
</dl>
<p>This routine sets the timing plan for an sonicsync master or slave node. The possible values are: SONICSYNC_TIME_PLAN_1 (0) SONICSYNC_TIME_PLAN_2 (1) SONICSYNC_TIME_PLAN_3 (2) SONICSYNC_TIME_PLAN_NONE (255)</p>
<p>For a master device, this value specifies the timing plan that will be used for the master and slave pair. (The default value of SONICSYNC_TIME_PLAN_1 is used if this routine is not called.) SONICSYNC_TIME_PLAN_NONE should not be specified as the master node time plan.</p>
<p>By default, a slave device initially uses SONICSYNC_TIME_PLAN_NONE, which causes the slave to cycle through the various time plans attempting to pair with the master. (This is the behavior if this routine is not called.) When the slave successfully discovers and pairs with the master, the successful time plan is recorded and then used for all subsequent exchanges, unless it is reset to SONICSYNC_TIME_PLAN_NONE by a call to this routine. Once the slave has successfully paired with a master device, the time plan value may be determined by calling the ch101_sonicsync_get_time_plan() routine.</p>
<p>However, a slave device may be forced to only use a single time plan by calling this routine before the master is discoverd. This may be desirable to speed up the master discovery or to avoid pairing with nearby sensor pairs that use a different time plan.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if successful. </dd></dl>

</div>
</div>
<a id="a501202a29786cb0457a244d0b0c42f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501202a29786cb0457a244d0b0c42f23">&#9670;&nbsp;</a></span>ch_set_tx_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ch_set_tx_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>tx_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the TX length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure </td></tr>
    <tr><td class="paramname">tx_length</td><td>the transmit length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, 1 if error</dd></dl>
<p>This function sets the length of the pulse to transmit with</p>
<dl class="section note"><dt>Note</dt><dd>This config is only available in select Chirp sensor firmware versions. </dd></dl>

</div>
</div>
<a id="ade5083e622e8cc3852a4193f6d8dce9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5083e622e8cc3852a4193f6d8dce9c">&#9670;&nbsp;</a></span>ch_trigger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ch_trigger </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structch__dev__t.html">ch_dev_t</a> *&#160;</td>
          <td class="paramname"><em>dev_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trigger a measurement on one sensor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dev_ptr</td><td>pointer to the <a class="el" href="structch__dev__t.html" title="Chirp sensor device structure. ">ch_dev_t</a> descriptor structure</td></tr>
  </table>
  </dd>
</dl>
<p>This function generates a pulse on the INT line for a single sensor. If the sensor is in either <em>CH_MODE_TRIGGERED_TX_RX</em> or <em>CH_MODE_TRIGGERED_RX_ONLY</em> mode, this pulse will begin a measurement cycle.</p>
<p>To simultaneously trigger all sensors in a group, use <em><a class="el" href="soniclib_8h.html#aa4e917eea19df611680dc97e2401db3a" title="Trigger a measurement on a group of sensors. ">ch_group_trigger()</a></em>.</p>
<dl class="section note"><dt>Note</dt><dd>Do not trigger a new measurement until the previous measurement has completed and all needed data has been read from the device (including I/Q data, if <em><a class="el" href="soniclib_8h.html#acde1c47209421107f576b7e01b6fa5e8" title="Get the raw I/Q measurement data from a sensor. ">ch_get_iq_data()</a></em> is used). If any I/O operations are still active, the new measurement may be corrupted. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
